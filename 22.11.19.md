## 자바 프로그래밍을 공부하는 이유?

* 기업에서 서버 프로그래밍시(백엔드 프로그래밍) 가장 많이 사용하는 언어

## 자바 언어의 특징

* 객체 지향 언어
* 느리지만, 버전업 되면서 다른 언어들의 장점들을 흡수(모던 자바: 8버전 이후)
* 17버전까지 나왔지만 기업에서는 11 또는 8 버전을 많이 사용
* 레거시(유산) 오래된 프로그램은 5버전도 사용
  * 람다(Lambda): 함수형 프로그래밍
  * Stream API: 람다 표현식과 메서드 참조 등의 기능과 결합해서 복잡한 데이터 처리 작업을 쉽게 조회, 필터링, 변환, 처리
  * 병렬 프로그래밍: 여러개의 CPU코어에서 작업을 배분해 동시 수행

## 자바 프로그램 작성과 실행

* JDK(Java Development Kit) 프로그램 필요 (openjdk, Oracle JDK, Azul Julu JDK ...)
* 기존에는 Oracle JDK를 주로 사용했으나 유료화가 되면서 오픈소스, 무료 JDK를 많이 사용하기 시작

```java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello");
    }
}
```

* 자바 프로그램 파일명 첫글자는 대문자
* public class 클래스명 { } 구조에서 클래스명은 파일명과 동일해야 한다.
* java 컴파일러 javac로 컴파일 `javac Hello.java`

  * 컴파일이란? 사람이 이해하는 언어를 컴퓨터가 이해할 수 있는 언어로 바꾸어 주는 과정
* 컴파일이 성공하면 Hello.class 파일이 생성된다.
* `ls -la` 명령어로 Hello.class 파일 확인
* JVM으로 Hello.class 실행 `java Hello` (.class 확장자 생략)

## Hello.java 파일 분석

```java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello");
    }
}
```

* `public class Hello { ... }`

  * public class로 정의된 Hello class
  * 클래스는 Field와 Method를 가질 수 있다.
    * 자바에서는 함수를 메소드라고 한다.
* `public static void main(String[] arg) { ... }`

  * 프로그램을 실행하려면 반드시 가져야 하는 main 메소드로 프로그램 시작점을 뜻함
* `System.out.println("Hello");`

  * 자바에서 첫글자가 대문자면 클래스라고 생각하면 된다.
  * System 클래스의 out 필드의 println 메소드를 사용한 예시이다.
  * System의 구성을 알려면 [java API 문서](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html)를 살펴봐야 한다.

## 컴파일

* 컴파일을 하려면 javac라는 프로그램이 필요하다.
  * javac: 자바 컴파일러
* `javac Hello.java`
  * Hello.java 파일 컴파일 후 성공하면 Hello.class 파일 생성, 실패하면 오류메세지
  * Hello.class: byte 파일로 구성
    * byte 코드 : 작성된 소스 코드를 JVM이 이해할 수 있는 중간 코드로 컴파일한 것을 말한다. JVM은 이 byte 코드를 한줄씩 읽어들이면서 각각의 하드웨어 아키텍처에 맞는 기계어로 바꿔가며 실행한다.(Interpreter 방식)

> C언어는 컴파일을 하면 기계어로 바로 바뀌지만 CPU마다 다른 명령어들을 가지고 있기 때문에 문제가 생길 수 있다. 하지만 자바는 CPU에 상관없이 여러 컴퓨터에서 실행될 수 있도록 바로 기계어로 바꾸지 않고 byte 코드로 바꾼 후에 기계어로 바꾸는 과정을 거친다. 이것이 가능한 이유는 Java에서 제공하는 JVM이 각 운영체제에 맞게 제공되기 때문이다. (M1 CPU용, Intel CPU용...)

## IDE

* 통합 개발 환경으로 코딩, 디버그, 컴파일, 배포 등 프로그램 개발에 관련된 모든 작업을 하나의 프로그램 안에서 처리하는 환경을 제공하는 소프트웨어이다.
* Java IDE: Eclipse, IntelliJ

## IntelliJ

* Jetbrains사에서 만든 IDE
* 프로젝트 폴더 아래의 .idea 폴더는 ItelliJ에서 프로젝트를 관리하기 위한 파일로 수정, 삭제 X
* 확장자가 iml인 파일은 IntellJ의 설정 파일로 수정, 삭제 X
* 사용자마다 IDE 설정은 다르게 사용하므로 여러 사람이 개발할 때에는 .idea 폴더나 iml 파일은 개발자마다 별도로 저장되도록 관리돼야 한다.
* 소스코드를 공유하는 시스템(형상 관리 서버 ex: github)에 소스코드를 올릴 때에는 IntelliJ 설정 파일을 올라가지 않도록 해야한다.
  * 설정 파일이 공유되게 되면 다른 사람의 설정이 내 설정을 덮여질 위험이 있다.
* 터미널에서 javac 명령으로 컴파일하고 java로 실행했었는데 그럴 필요없이 IntelliJ에선 간단하게 실행 가능하다.

## 변수와 리터럴

```java
int i=1;
```

* int: 정수 type을 나타내는 키워드

  * 키워드란? java에서 정한 예약어
* i: 값을 가질 수 있는 메모리의 어떤 영역

  * 컴퓨터는 정수 하나를 저장하기 위해 메모리에 4byte 크기의 저장 공간을 필요로 한다.
* 1: 정수 리터럴(literal) 1

  * 리터럴이란? 변수에 입력되는 값


## 데이터 타입


![](https://blog.kakaocdn.net/dn/3bPej/btqP9s6FxuH/edEI83ZDTA8K6lbUwzaVR1/img.jpg)


* 기본형(Primitive) 타입
  * 정해진 크기의 메모리를 확보하고 그 메모리 안에 값을 저장한다.
  * 논리형 타입: boolean
  * 정수형 타입: byte, short, int, long
  * 실수형 타입: float, double
  * 문자형 타입: char


* 참조형(reference) 타입
  * 첫글자가 대문자로 기본형을 제외한 모든 타입
  * class, interface ...
  * 값을 가지지 않고 값을 참조한다.


## True or False

* True or False를 저장하는 변수를 논리형 타입 변수라고 한다.
* boolean형 타입 변수는 T or F 두 가지 값 중 하나를 가지고, 초기화하지 않으면 디폴트로 false값을 가진다.
* 메소드 안에서 변수를 선언한 후 초기화하지 않고 사용하면 오류가 발생한다.

  * `java: variable 변수명 might not have been initialized`

> 논리연산자 ^ (exclusive-or 또는 XOR)
>
> : 2개의 식의 논리값이 서로 다를 경우 True.


> &&와 &, ||와 |의 차이
>
> * &&: 앞의 식이 거짓일 경우 뒤의 식 보지도 않고 False 넣고 넘어감
> * &: 앞의 식이 거짓이어도 뒤의 식까지 실행 후 Fasle 넣음
>
> * ||: 앞의 식이 참일 경우 뒤의 식 보지도 않고 True 넣고 넘어감
> * |: 앞의 식이 참이어도 뒤의 식까지 실행 후 True 넣음
>
> 뒤에 만약 연산식이 있다면 둘의 차이는 분명해진다.




## 오버플로우(overflow)

* 계산 결과가 최댓값을 넘거나 최솟값보다 작을 경우 음수는 양수로, 양수는 음수로 바뀌는 문제
* 1byte가 표현하는 가장 큰 값은 01111111이다. 여기서 +1을 한다면 10000000이 되는데 맨 왼쪽 비트는 부호 비트라서 부호 비트가 1이 되어버려 음수가 되는 것이다.
* 실수형에서 오버플로우 발생 시 변수의 값은 무한대가 된다.
* 강제 형변환 시 범위가 넘지 않는 선에서 해야 오버플로우가 발생하지 않는다.


## 비트연산자

* 비트란? 컴퓨터가 처리하는 정보의 최소 단위
* 많은 데이터를 나태내기 위해 8개의 비트를 묶은 바이트를 사용
* 1byte는 00000000 ~ 11111111 까지 표현할 수 있다.
  * 정수로는 0~254
  * 16진수로는 00~FF (4비트는 0 ~ 15까지 표현가능하기 때문)



![비트연산](https://velog.velcdn.com/images%2Feledev%2Fpost%2Fbcebdebb-86fc-405d-8d99-9ea6ca70e1ce%2Fimage.png)

* 비트 연산자는 바이트를 구성하고 있는 비트를 연산하는 연산자이다.
* 왼쪽 시프트 연산자는 2^n으로 나누면 되고 오른쪽 시프트 연산자는 2^n으로 곱하면 된다.


## break와 continue문의 한계

* break는 현재 반복문을 빠져나가는데 사용하고, continue는 continue문 아래 부분을 실행하지 않고 다시 반복한다.
* 그럼 2중for문을 한번에 빠져나가려면? continue이하를 실행하지 않고 한번에 2중for문을 반복하려면 어떻게 해야할까?
  * label을 사용한다.

```java
        outter:
        for (int i = 0; i < 3; i++) {
            for (int k = 0; k < 3; k++) {
                if (i == 0 && k == 2)
                    break outter;
                System.out.println(i + ", " + k);
            }
        }
```



[결과]

```java
1, 0
1, 1
1, 2
2, 0
2, 1
2, 2
```java
outter:
        for (int i = 0; i < 3; i++) {
            for (int k = 0; k < 3; k++) {
                if (i == 0 && k == 2)
                    continue outter;
                System.out.println(i + ", " + k);
            }
        }
```
[결과]

```java
0, 0
0, 1
1, 0
1, 1
1, 2
2, 0
2, 1
2, 2
```
