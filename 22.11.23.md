## 상속

OO는 OO다. OO는 OO의 종류 중 하나다. 라고 표현할 수 있다면 이것은 상속이다.


* 일반화시키기 (여러 종류의 객체를 하나의 이름으로 부를 수 있는 것)
  * TV는 전자제품이다.
  * 세탁기는 전자제품이다.
* 전자제품을 상속받은 TV, 세탁기는 모두 끄다(), 켜다() 메소드를 가진다.


상속 = 일반화 + 확장

* 부모클래스를 상속받는다는 것은 부모가 가진 것을 자식이 물려받아 사용할 수 있다는 것
* 좋은 객체란 응집도는 높이고 결합도는 낮추는 것이라 했는데 상속은 굉장히 강한 결합이므로 잘못 상속받으면 타격이 너무 크기에 반드시 써야만 할 때에 사용해야 한다.
* 최대한 상속을 쓰지 않도록 하자..!


#### 아무것도 상속받지 않으면 자동으로 java.lang.Object를 상속받는다

모든 클래스는 Object의 자손이다.(최상위 클래스)


## 다형성 - 메소드 오버라이딩(Overriding)

* 상위 클래스의 메서드를 하위 클래스가 재정의하는 것
* 메소드의 이름, 파라미터의 갯수, 타입이 동일해야 한다.


#### 메소드가 오버라이딩 되면 무조건 자식의 메소드가 실행된다!

```java
public class Car {
    public void run() {
        System.out.println("전륜구동");
    }
}
```

```java
public class Bus extends Car {
    @Override
    public void run() {
        System.out.println("후륜구동");
    }
}
```

```java
 public static void main(String[] args) {
        Bus b1 = new Bus();
        b1.run();

        Car c1 = new Car();
        c1.run();   

        Car c2 = new Bus();
        c2.run();   // 메소드가 오버라이딩되면 무조건 자식 메소드 실행!
    }
```

[실행결과]

```java
후륜구동
전륜구동
후륜구동
```


`Car c1 = new Bus();` 참조 타입을 Car로 하고 Bus 인스턴스를 생성했을 경우 Car 타입의 메소드인 run()만 사용이 가능하고 Bus의 다른 추가적인 메소드는 사용 불가능하다. 만약 사용하고 싶으면 다음과 같이 타입을 바꿔줘야 한다.

```java
Car c1 = new Bus();
c1.run()
Bus b1 = (Bus)c1;
b1.안내방송();
```

이것이 가능한 이유는 c1이 참조하는 것이 Bus 인스턴스이기 때문에 이걸 Bus 타입으로 변환해서 b1이 참조하게 했기 때문이다.


## 필드, 메소드 오버라이딩 시 주의점

필드는 Type을 따라가고 메소드는 오버라이딩된 자식의 메소드가 실행된다!

```java
public class Parent {
    int i = 5;
    public void printII() {
        System.out.println(i * 2);
    }
    public void printI() {
        System.out.println("parent - printI(): " + i);
    }
}

```


```java
public class Child extends Parent {
    public int i = 15;      // 필드 오버라이딩
    public void printI() {      // 메소드 오버라이딩
        System.out.println("child - printI(): " + i);
    }
}
```


```java

public static void main(String[] args) {
        Parent p1 = new Parent();
        System.out.println(p1.i);
        p1.printI();
        p1.printII();

        System.out.println("-------------------------");
        Child c1 = new Child();
        System.out.println(c1.i);
        c1.printI();
        c1.printII();

        System.out.println("-------------------------");
        Parent p2 = new Child();
        System.out.println(p2.i);       // 필드는 타입을 따라가고
        p2.printI();                    // 메소드는 자식 메소드를 따라간다
        p2.printII();
    }
```

[실행결과]

```java
5
parent - printI(): 5
10
-------------------------
15
child - printI(): 15
10
-------------------------
5
child - printI(): 15
10
```

#### 정보 은닉(information hiding)은 객체지향의 중요한 기법이다. 중요한 필드는 은닉해서 외부에서 직접 접근할 수 없도록 하고, 필드는 메소드를 통해서만 접근해서 사용하도록 코딩해야 한다.

* 위 코드의 경우 `System.out.println(c1.i);` 같은 코드가 필드에 직접 접근하는 코드이므로 좋지 않다.


## Getter & Setter 프로퍼티

private로 필드를 은닉화했을 때 이 필드의 값을 수정하고 얻기 위해 Getter, Setter 메소드를 사용한다.

```java
public class Book {
    private String title;   // field price
    private int price;

    // setter, getter - 프로퍼티(property)
    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }
}

```

* getter, setter는 프로퍼티이다. 위 코드에서는 title 프로퍼티, price 프로퍼티 총 2개의 프로퍼티가 존재

> this는 내 자신 인스턴스를 참조하는 예약어로 클래스 메소드에서는 사용이 불가능하다.(메모리에 생성되는 시점이 다르므로)



## 오버라이딩하라고 만든 Object의 메소드


Object가 오버라이딩하라고 제공하는 메소드

* toString()
* equals() & hashCode()

```java
    public static void main(String[] args) {
        Car c1 = new Car();
        System.out.println(c1); 
    }
```

[실행결과]

`Car@7c75222b`


Syste.out의 println 메소드들을 보면 print(Object x)가 있다. 위의 경우 Object 인자를 받아 출력한 경우이다. 부모타입의 변수로 자식 인스턴스를 참조할 수 있고, 조상 타입의 변수로도 후손 인스턴스를 참조할 수 있다고 했었다. Object는 모든 클래스의 조상이므로 가능한 것이다.

```java
public class PrintStream extends FilterOutputStream
    implements Appendable, Closeable
{
    ...

    public void println(Object x) {
        String s = String.valueOf(x);
        synchronized (this) {
            print(s);
            newLine();
        }
    }

    ...
}
```

실제로 println(Object x) 코드를 까보면 Object x를 받아서 문자열로 만들어준 후 문자열을 받는 print()로 넣어준다.

valueOf()를 또 따라 들어가 보면 obj가 null이면 "null"을 아니면 obj의 toString() 값을 리턴해주고 있다.

```java
public static String valueOf(Object obj) {
        return (obj == null) ? "null" : obj.toString();
    }
```

즉, println(Obejct x)는 Object x의 toString()값을 출력해주는 것이다.

toString()을 오버라이딩 해주면 원하는 출력 형태로 출력할 수 있게 된다.


#### equals 메소드는 값을 비교하는 기준이 필요하기 때문에 오버라이딩이 필요하다.

> hashCode()
>
> * hash 코드를 만들어내는 기능
> * 값이 같은지 비교하는 기능



## 생성자

* 인스턴스를 생성할 때 사용
* 클래스 작성 시 생성자를 하나도 만들지 않으면 자동으로 기본 생성자 생성
  * 기본생성자 : 매개변수를 하나도 받지 않는 생성자
