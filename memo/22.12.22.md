## DataInputStream, DataOutputStream

* 기본형 타입과 문자열을 읽고 쓸 수 있다.

```java
public static void main(String[] args) throws IOException {
        // 이름, 국어점수, 영어점수, 수학점수, 평균점수를 /tmp/score.dat 파일에 저장하시오.
        String name = "kim";
        int kor = 90;
        int eng = 50;
        int math = 70;

        double total = kor + eng + math;
        double avg = total / 3.0;

        DataOutputStream out = new DataOutputStream(new FileOutputStream("/tmp/score.dat"));
        out.writeUTF(name);
        out.writeInt(kor);
        out.writeInt(eng);
        out.writeInt(math);
        out.writeDouble(total);
        out.writeDouble(avg);
        out.close();


        // 파일에서 읽어오기
        DataInputStream dataInputStream = new DataInputStream(new FileInputStream("/tmp/score.dat"));

        System.out.println(dataInputStream.readUTF());
        System.out.println(dataInputStream.readInt());
        System.out.println(dataInputStream.readInt());
        System.out.println(dataInputStream.readInt());
        System.out.println(dataInputStream.readDouble());
        System.out.println(dataInputStream.readDouble());


    }
```

## ByteArrayInputStream, ByteArrayOutputStream

* byte[]에 데이터를 읽고 쓰기

```java
public static void main(String[] args) throws IOException {

        // 쓰기
        int data1 = 1;
        int data2 = 2;

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        out.write(data1);   // data1의 마지막 1byte 저장
        out.write(data2);
        out.close();

        byte[] array = out.toByteArray();


        // 읽기
        ByteArrayInputStream in = new ByteArrayInputStream(array);
        int read1 = in.read();
        int read2 = in.read();
        int read3 = in.read();  // -1
        in.close();

        System.out.println(read1);
        System.out.println(read2);
        System.out.println(read3);
    }
```

## CharArrayReader, CharArrayWriter

* char[]에 데이터 읽고 쓰기

```java
public static void main(String[] args) throws IOException {
        char a = 'a';
        char b = 'b';
        char c = 'c';

        CharArrayWriter cw = new CharArrayWriter();
        cw.write(a);
        cw.write(b);
        cw.write(c);
        cw.close();

        char[] arr = cw.toCharArray();
        String str = cw.toString();

        CharArrayReader cr = new CharArrayReader(arr);
        char read1 = (char) cr.read();
        char read2 = (char) cr.read();
        char read3 = (char) cr.read();

        System.out.println(read1);
        System.out.println(read2);
        System.out.println(read3);
    }
```

## StringReader, StringWriter

* 문자열 읽고 쓰기

```java
public static void main(String[] args) throws IOException {
        StringWriter sw = new StringWriter();
        sw.write("hello");
        sw.write("world");
        sw.write("!!!");
        sw.close();

        String str = sw.toString();

        StringReader sr = new StringReader("helloworld!!!");
        int ch = -1;

        while ((ch = sr.read()) != -1) {
            System.out.print((char)ch);
        }

        sr.close();
    }
```


## ObjecInputStream, ObjectOutputStream

* 직렬화 가능한 대상을 읽고 쓰기
* 직렬화란? 객체를 직렬화하여 전송 가능한 형태로 만드는 것
* 직렬화 가능한 대상이란? 기본형 타입 or java.io.Serializable 인터페이스를 구현하고 있는 객체
  * java.io.Serializable 인터페이스는 메소드가 하나도 없어서 구현만 해주면 된다.
  * 이렇게 메소드가 없는 인터페이스를 마크(표시) 인터페이스라고 한다.


Serializable을 구현한 User 객체 (전송할 객체)

```java
public class User implements Serializable {
    private String email;
    private String name;
    private int birthYear;

    public User(String email, String name, int birthYear) {
        this.email = email;
        this.name = name;
        this.birthYear = birthYear;
    }

    public String getEmail() {
        return email;
    }

    public String getName() {
        return name;
    }

    public int getBirthYear() {
        return birthYear;
    }

    @Override
    public String toString() {
        return "User{" +
                "email='" + email + '\'' +
                ", name='" + name + '\'' +
                ", birthYear=" + birthYear +
                '}';
    }
}
```

User 객체가 직렬화 가능하다는 것은 그 필드들도 직렬화 가능해야 한다. String을 뜯어보면 java.io.Serializable 인터페이스를 구현하고 있고, int는 기본형 타입이므로 직렬화 가능하다.

```java
public static void main(String[] args) throws IOException, ClassNotFoundException {
        // 직렬화 가능한 객체 생성
        User user = new User("lee@naver.com", "lee", 1999);

        // 객체 저장
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("/tmp/user.dat"));
        out.writeObject(user);
        out.close();

        // 객체 읽어오기
        ObjectInputStream in = new ObjectInputStream(new FileInputStream("/tmp/user.dat"));
        User u = (User) in.readObject();
        in.close();

        System.out.println(u);
    }
```


ArrayList도 Serializable을 구현한 것이므로 직렬화 가능하다.

```java
public static void main(String[] args) throws IOException, ClassNotFoundException {
        User u1 = new User("lee@naver.com", "lee", 1999);
        User u2 = new User("kim@naver.com", "kim", 2003);
        User u3 = new User("park@naver.com", "park", 2010);

        ArrayList<User> users = new ArrayList<>();

        users.add(u1);
        users.add(u2);
        users.add(u3);

        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("/tmp/userlist.dat"));
        out.writeObject(users);
        out.close();

        ObjectInputStream in = new ObjectInputStream(new FileInputStream("/tmp/userlist.dat"));

        ArrayList<User> list = (ArrayList<User>) in.readObject();
        in.close();

        for (User a : list) {
            System.out.println(a);
        }
    }
```


**깊은 복사를 위한 직렬화**

```java
public static void main(String[] args) throws IOException, ClassNotFoundException {
        User u1 = new User("lee@naver.com", "lee", 1999);
        User u2 = new User("kim@naver.com", "kim", 2003);
        User u3 = new User("park@naver.com", "park", 2010);

        ArrayList<User> users = new ArrayList<>();
        users.add(u1);
        users.add(u2);
        users.add(u3);

        // 얉은 복사1
        ArrayList<User> users2 = users;


        // 얉은 복사2
        ArrayList<User> users3 = new ArrayList<>();
        for (User u : users2) {
            users3.add(u);
        }

        // 깊은 복사
        ArrayList<User> users4 = copy(users);

        for (User u : users4) {
            System.out.println(u);
        }
    }

    private static ArrayList<User> copy(ArrayList<User> users) throws IOException, ClassNotFoundException {
        // 깊은 복사를 위해선 직렬화가 필요하다.
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        ObjectOutputStream out = new ObjectOutputStream(bout);

        out.writeObject(users);

        out.close();
        bout.close();

        byte[] array = bout.toByteArray();

        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(array));
        ArrayList<User> userList = (ArrayList<User>) in.readObject();

        in.close();

        return userList;

    }
```
