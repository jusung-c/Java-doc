### JavaDoc 주석문

* /** ... */
* 사용하는 태그들

![image.png](assets/image.png)

```java
/**
 * List 인터페이스 실습
 * 
 * @author jus 
 * @since 22.12.10
 * @version 1.0
 * 
 */

public class List01 {
    ...
}
```

#### IntelliJ에서 JavaDoc 생성하기

1. shift키 연속 2번
2. generate javaDoc 입력
3. custom scope 선택 - JavaDoc 생성할 패키지, 클래스, 인터페이스 등 선택 (exclude로 제외 지정 가능)
4. output directory - JavaDoc 생성할 경로 지정
5. other command line arguments에 다음 입력`-encoding UTF-8 -charset UTF-8 -docencoding UTF-8`

> 주석문을 잘 작성하는 방법은 주석문을 작성하지 않는 것이다.. 최소한으로 작성하자

## 예외(Exception) 처리

자바에서는 실행 시 2가지 형태의 오류가 발생할 수 있다.

1. Error: 수습할 수 없는 심각한 오류메모리 부족, 스택오버플로우 등이 발생하여 프로그램이 죽는 것은 프로그래머가 제어할 수 없다.
2. Exception: 예외 처리를 통해 수습할 수 있는 덜 심각한 오류

Error의 종류

* 컴파일시 발생하는 컴파일 에러
* 실행시 발생하는 런타임 에러

```java
public class Exception01 {
    public static void main(String[] args) {
        ExceptionObj1 exobj1 = new ExceptionObj1();
        int value = exobj1.divide(10, 0);
        System.out.println(value);
    }
}

class ExceptionObj1 {
    public int divide(int i, int k) {
        int value = 0;
        value = i / k;
        return value;
    }
}

```

0으로 나눌 수는 없기 때문에 java.lang.ArithmeticException 익셉션이 발생하면서 프로그램이 강제종료 된다.

익셉션을 발생할 때에는 JVM이 ArithmeticException 인스턴스 객체를 만들어서 발생해준다.

#### 예외 처리하기 (try-catch)

익셉션이 발생하는 코드에 try-catch 구문을 통해 예외를 처리해준다.

```java
try {
            value = i / k;
        } catch (ArithmeticException e) {
            System.out.println("0으로 나눌 수 없어요");
            System.out.println(e.toString());
        }
```

catch를 통해 익셉션을 발생시킨 객체를 잡아서 e 변수로 참조시킨다.

[결과]

0으로 나눌 수 없어요
java.lang.ArithmeticException: / by zero
0

10을 0으로 나누면 결과는 나오지 않는다. 근데 지금처럼 예외처리를 하면 value가 초기값인 0으로 출력된다. 이럴거면 차라리 익셉션이 발생하고 프로그램이 종료된 게 낫다. 에러나는 것보다 못한 결과. 이게 만약 돈과 관련된 프로그램에서 저 value 값이 사용된다고 생각해보면 끔찍한 일이 생길 것이다.

또 다른 문제는 사용자가 원하지 않는 메세지를 출력한다는 것이다. println으로 출력하는 클래스는 다른 사용자가 그 클래스를 사용했을 때에 원하지 않는 메세지가 출력되는 문제가 발생한다.

### 예외 떠넘기기(throws)

```java
public class Exception01 {
    public static void main(String[] args) {
        ExceptionObj1 exobj1 = new ExceptionObj1();
        try {
            int value = exobj1.divide(10, 0);
            System.out.println(value);
        } catch (ArithmeticException e) {
            System.out.println("0으로 나눌 수 없습니다.");
        }
    }
}

class ExceptionObj1 {
    public int divide(int i, int k) throws ArithmeticException{
        int value = 0;
        value = i / k;
  
        return value;
    }
}

```

이렇게 throws로 익셉션을 떠넘겨주면 사용하는 쪽(호출하는 쪽)에서 try catch 구문으로 예외를 처리해주면 된다. 원치 않는 메세지도 뜨지 않고, javaDoc을 통해 사용할 때 try catch만 해주면 되므로 앞의 예제보다 좋은 코드이다.

### RuntimeException과 Checked Exception

![](https://postfiles.pstatic.net/MjAyMTA2MDdfMjY5/MDAxNjIzMDc1MzA1MjE0.zdToN8ysCmBoiq_S6xJJotQtdwUa295xL4I0uMXc1Z0g.mBcNzd0chtF1EG_P8wZ0J_kBhwhM8EEX-HLXDto7vmQg.PNG.hj_kim97/123123.PNG?type=w966)

RuntimeException를 상속받고 있으면 다 RuntimeException이라고 할 수 있다. 이전에 발생한 ArithmeticException도 RuntimeException이다.

RuntimeException은 컴파일 시에 오류가 나지 않지만 실행 시에 오류가 발생한다. 실행시에 오류가 나서 프로그램을 죽이는 익셉션을 RuntimeException이라고 한다. 실행 시에 발생하므로 실행을 해보고 경험을 통해 수습하는 방법이 일반적이다.

Checked Exception은 RuntimeException을 상속받지 않은 익셉션을 뜻한다. IOException 등..

```java
    public static void main(String[] args) {
        FileInputStream fis = new FileInputStream("Exception01.java");
    }
```

FileInputStream을 사용할 때 위처럼만 작성하면 생성자부분에서 에러표시가 발생한다. 에러의 이유를 보면 익셉션 처리를 안해줘서이다.

FileInputStream의 코드를 보자.

```ㅓㅁㅍㅁ
    public FileInputStream(String name) throws FileNotFoundException {
        this(name != null ? new File(name) : null);
    }
```

FileInputStream은 FileNotFoundException을 throws로 넘기고 있다.

그럼 FileNoFoundException의 코드를 보자.

```ㅓㅁㅍㅁ
public class FileNotFoundException extends IOException {
    ...
}
```

IOException을 상속받고 있고, IOException은 Exception을 상속받고 있다.

![image.png](assets/image_Exception.png)

RuntimeException을 상속받고 있지 않으므로 CheckedException이다. FileInputStream을 사용할 때에는 반드시 Exception 처리를 해줘야 한다.

* try-catch 예외 처리

```ㅓㅁㅍㅁ
public static void main(String[] args) {
        try {
            FileInputStream fis = new FileInputStream("Exception01.java");
        } catch (FileNotFoundException e) {
            System.out.println("파일을 찾을 수 없습니다.");
        }
    }
```

* throws 예외 떠넘기기 - 이 메소드를 호출한 쪽으로 예외처리를 떠넘긴다.

```java
public static void main(String[] args) throws FileNotFoundException{
        FileInputStream fis = new FileInputStream("Exception01.java");
    }
```

하지만 여기선 main이라서 main을 실행해주는 것은 JVM인데 JVM에게 예외처리를 떠넘기는 것은 무책임한 행동이다.

만약 나만의 Exception을 만들 때 RuntimeException이 좋을까 CheckedException이 좋을까?

컴파일 시에 에러를 띄워주는 CheckedException이 좋다고 생각할 수 있지만 바람직하지 않다. CheckedException이 많아지면 복잡해지고 사용자에게 강요할 것이 많아지므로 되도록이면 RuntimeException을 상속받은 익셉션을 만들어서 사용자가 사용하기 좋도록 만드는 게 좋다.

### 다중 Exception 처리

```ㅓㅁㅍㅁ
public class Exception01 {
    public static void main(String[] args) {
        int[] array1 = {4, 0};   //  1번
        int[] array2 = {4, 2};   //  2번
        int[] array3 = {4};   //  3번

        int[] value = null;

        try {
            value[0] = array1[0] / array1[1];
        } catch (ArrayIndexOutOfBoundsException aiobe) {    // 3번
            System.out.println(aiobe.toString());   
        } catch (ArithmeticException ae) {                  // 1번
            System.out.println(ae.toString());
        } catch (Exception e) {                             // 2번
            System.out.println(e.toString());
        }

    }
}

```

1번 : java.lang.ArithmeticException: / by zero

2번 : java.lang.NullPointerException

3번 : java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1

Exception은 모든 익셉션의 조상이라서 다 지우고 Exception만 해줘도 되지 않을까? 그래도 되긴 하지만 특별히 처리하고 싶을 경우에 구체적인 익셉션에 대한 예외 처리를 해줘야 한다. 지금이야 그냥 익셉션 내용만 출력하고 있지만 나중엔 익셉션 케이스별로 다른 동작을 처리하게 설계를 해야할 때가 있다.

그래도 마지막에 꼭 Exception을 예외처리 해줘서 내가 예상하지 못한 익셉션이 발생했을 때를 대비한 방어적인 코드를 적어주는 게 좋다.

### 사용자 정의 Exception

```ㅓㅁㅍㅁ
public class Exception01 {
    public static void main(String[] args) {
        try {
            ExceptionObj eobj = new ExceptionObj();
            int value = eobj.divide(10, 0);
            System.out.println(value);
        } catch (MyException me) {
            System.out.println("사용자 정의 익셉션 발생");
        }
    }
}

class ExceptionObj {
    public int divide(int i, int k) throws MyException {
        int value = 0;
        try {
            value = i / k;
        } catch (ArithmeticException arithmeticException) {
            throw new MyException("0으로 나눌 수 없습니다.");
        }
        return value;
    }
}
```

가정) 모두를 위해 만든 실용적인 MyUtil 클래스

MyUtil이라는 클래스에는 a, b, c의 유용한 메소드가 있다. a, b, c 안에서 다양한 라이브러리, 클래스들을 이용해 기능을 구현해놨다. 다양한 클래스를 사용한 만큼 다양한 익셉션이 발생할 수 있다. a안에서 발생한 익셉션을 직접 처리하고 싶지 않다면 a메소드를 선언할 때 throws를 통해 다 적어줘야 한다.

`a() throws ..., ..., ..., ...`

이렇게 하면 a를 사용하는 사람이 try-catch로 익셉션을 처리해 사용하면 되는데 매우 귀찮은 과정이다.

그래서 a 메소드 안에서 try-catch 문으로 다양한 익셉션을 e로 받은 후 `throw new MyException("...")` 으로 하나의 새로운 익셉션으로 바꿔준 후 a를 선언할 때 `a() throws MyException`만 해주면 된다.

이렇게 하면 사용하는 입장에서도 간단하게 MyException에 대한 예외처리만 try-catch로 해주면 된다.

## Enum

* JDK 5부터 지원
* JDK 5이전에 어떤 상수들을 표현하고자 하면 다음과 같은 클래스를 작성했다.

```java
public class DayType {
    public final static int SUNDAY = 0;
    public final static int MONDAY = 1;
    public final static int TUESDAY = 2;
    ...
}
```

`int today = DayType.SUNDAY;`

문제는 today는 int형이므로 날짜를 나타내는 0~6 사이의 정수 이외에도 다른 정수를 가질 수 있다.

`today=100;`

정해진 값만 변수에 할당할 수 없는 문제가 생기는 것이다. 이런 문제는 타입에 안전하지 않다. 이를 해결하기 위해 등장한 문법이 Enum이다.

* 클래스 생성과 같은 방식
* com.example.enumtype 패키지

```java
public enum Day {
    SUNDAY,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY
}
```

```java
private Day today;
today.setDay(Day.SUNDAY);
```

이렇게 Day 타입으로 변수를 선언해두면 Enum으로 미리 정의해둔 값들만 가질 수 있게 되어 안전하다.

#### switch문에서 사용되는 Enum

```ㅓㅁㅍㅁ
        Day day = Day.SUNDAY;

        switch (day) {
            case SUNDAY:
                System.out.println("일");
                break;
            case MONDAY:
                System.out.println("월");
                break;
            default:
                System.out.println("그 밖의 요일");
        }        Day day = Day.SUNDAY;

        switch (day) {
            case SUNDAY:
                System.out.println("일");
                break;
            case MONDAY:
                System.out.println("월");
                break;
            default:
                System.out.println("그 밖의 요일");
        }
```

> switch 문에서 Enum 타입을 사용할 때 Day.SUNDAY가 아닌 그냥 선언해둔 상수 이름 SUNDAY로 접근한다.



#### Enum 타입의 특징

* Enum 생성자와 값 지정 가능
* Enum은 생성자를 가질 수 있다. 단, 생성자는 private해야 한다.
* Enum의 생성자는 내부에서만 호출 가능

```java
public enum Gender {
    MALE("XY"),
    FEMAIL("XX");
  
    private String chromosome; // 염색체

    private Gender(String chromosome) {
        this.chromosome = chromosome;
    }
}
```

```java
        Gender gender = Gender.MALE;
        System.out.println(gender);
```

[결과]

MALE


MALE의 chromosome 값을 출력하고 싶다면? 

#### Enum에 메소드와 변수 선언

* Enum 안에 메소드와 변수를 선언할 수 있고, Object가 가진 메소드를 오버라이딩할 수도 있다.
* Gender에 Object가 가진 toString()을 오버라이딩 하자

```ㅓㅁㅍㅁ
    @Override
    public String toString() {
        return "Gender{" +
                "chromosome='" + chromosome + '\'' +
                '}';
    }
```

이렇게 해준 후 다시 출력해보면 chromosome 값이 출력된다.

Gender{chromosome='XY'}


#### Enum 값 끼리의 비교

* Enum은 상수기 때문에 메모리에 딱 하나만 올라간다. 상수는 변하지 않는 값이라서 메모리에 여러 개 있을 필요가 없기 때문이다. 그래서 비교를 할 때에는 ==을 사용한다.
* 인스턴스는 매번 생성할 때마다 다른 메모리에 저장되므로 ==를 사용하면 참조변수의 참조값을 비교하고, 메모리 값을 비교하고 싶을 때에는 equals() 메소드를 사용했다.


### EnumMap

* Enum 타입을 키로 사용할 수 있도록 도와주는 클래스
* java.lang.util.EnumMap

```java
    public static void main(String[] args) {
        EnumMap emap = new EnumMap(Gender.class);
        emap.put(Gender.MALE, "남자!!");
        emap.put(Gender.FEMAIL, "여자!!");

        System.out.println(emap.get(Gender.MALE));
        System.out.println(emap.get(Gender.FEMAIL));
    }
```

[결과]

남자!!
여자!!


### EnumSet

Enum 상수를 Set 자료구조로 다루기 위한 메소드를 제공하는 클래스

```java
    public static void main(String[] args) {
        EnumSet eset = EnumSet.allOf(Gender.class);

        // eset 모든 원소 출력
        Iterator<Gender> genderIter = eset.iterator();
        while (genderIter.hasNext()) {
            Gender gender = genderIter.next();
            System.out.println(gender);
        }
    }
```


#### Enum은 인터페이스를 구현할 수 있다.

```java
public interface Printer {
    public void print();
}
```

```java
public enum Gender implements Printer{
    ...

    @Override
    public void print() {
        System.out.println("염색체: " + chromosome);
    }
}
```



#### Enum은 추상메소드를 가질 수 있다.

추상 메소드를 가질 경우 상수를 정의할 때 추상메소드를 함께 구현해줘야 한다.

```ㅓㅁㅍㅁ
public enum Country {
    KOREA{
        @Override
        public void print() {
            System.out.println("대한민국");
        }
    },
    JAPAN{
        @Override
        public void print() {
            System.out.println("일본");
        }
    };
  
    public abstract void print();
}

```

```java
        Country country = Country.KOREA;
        country.print();
```

[결과]

대한민국


KOREA가 오버라이딩한 print() 메소드가 호출된 것을 확인할 수 있다.


#### 그외 Enum 특징

* Enum 객체는 Enum 상수가 처음 호출되거나 참조될 때 생성
* Enum은 Serializable과 Comparable 인터페이스를 이미 구현하고 있다.

> Serializable: JVM에서 해당 객체를 저장하거나, 다른 서버로 전송할 수 있도록 해준다.
