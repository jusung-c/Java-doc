## 제네릭

무엇이든 담을 수 있는 상자를 만들어 보자.

```java
public class ObjectBox {
    private Object object;

    public void set(Object obj) {
        this.object = obj;
    }

    public Object get() {
        return this.object;
    }
}
```


Object 타입은 모든 타입의 조상이므로 무엇이든 담을 수 있는 상자에 적합하다. 다만 꺼내서 사용할 때에는 타입에 맞춰 변환해줘야 한다.

```java
        ObjectBox box = new ObjectBox();
        box.set("kim");
        String str = (String) box.get();
        System.out.println(str.toUpperCase());

        box.set(new Integer(5));
        Integer i = (Integer) box.get();
        System.out.println(i.intValue());
```


그러나 매번 이렇게 꺼낼때마다 형변환이 필요한 단점이 있다. 보통 Object를 받기보다는 특정 물품을 담는 상자를 만들때가 많기 때문에 더 범용적인 상자를 만들 필요가 있다. 제네릭을 사용하면 가능하다.

```java
public class GenericBox<T> {
    private T t;
  
    public void add(T obj) {
        this.t = obj;
    }

    public T getT() {
        return this.t;
    }
}
```

```java
    public static void main(String[] args) {
        GenericBox<String> genericBox = new GenericBox<>();
        genericBox.add("kim");
        String str = genericBox.getT();
        System.out.println(str.toUpperCase());

        // genericBox.add(new Integer(5)); String이 아니기 때문에 컴파일 오류 발생
    }
```

* T는 제네릭과 관련된 부분으로 T라는 이름의 제네릭 타입을 선언한다는 것을 의미한다.
* 제네릭은 클래스 이름 뒤나, 메소드의 리턴타입 앞에 붙을 수 있다.
* T는 Type의 약자이기에 쓰지만 꼭 T가 아니어도 된다.


#### 제네릭의 장점

* 정해진 타입만 사용하도록 강제할 수 있다.
* 컴파일 시 잘못된 타입의 값이 저장되는 것을 막을 수 있다.
* 매번 형변환해줄 필요가 없다.


### 컬렉션 프레임워크(Collection Framework)

* Java Collections Framework라고 불리는 Collections API는 Java 2부터 추가된 자료구조 클래스 패키지를 말한다.
* 자료(Data)를 다룰 때 반드시 필요한 클래스의 모음으로 꼭 숙지해야 한다.

![JAVA Collection Framework (1) - 컬렉션 프레임워크란?](https://hudi.blog/static/1bacac1babc556100455a8c64e7658da/e6c4b/2.png)


Collection 인터페이스는 자료를 다루기 때문에 자료를 추가하는 add 메소드를 가지고 있고, 그 자료의 크기를 알기 위한 size 메소드 등 여러 메소드들이 있다.

자료를 꺼내기 위해서는 2가지 기능이 필요하다. 하나는 꺼낼 자료가 있는 지 없는 지 확인하는 기능, 둘은 꺼내는 기능이다. 이 둘을 표한한 기능이 iterator 인터페이스이다. iterator은 boolean형을 리턴하는 hasNext라는 메소드를 가지고 있는데 꺼낼게 있으면 true 없으면 false를 반환한다. next()라는 메소드는 하나 꺼내는 메소드이다.

> 이터레이터는 디자인 패턴의 이름이기도 하다. 모든 것을 꺼내기 위한 패턴.


Collection 인터페이스는 자료를 담는 바구니라고 생각하면 좋다. 배열과 다르게 자료를 넣어도 순서를 알 수 없는 것이다. 그래서 컬렉션에 들어있는 것을 꺼내기 위해 iterator 메소드를 이용하는 것이다.


**Collection을 상속받은 인터페이스 -java.util.Collection**

* 상속받은 클래스들은 Collection이 가진 add(), size(), iterator() 등의 메소드를 가지고 있다.
* List 인터페이스는 마찬가지로 객체를 담아두기 위한 인터페이스인데 특별히 순서를 저장하는 인터페이스이다. 순서를 저장하기 때문에 배열처럼 get으로 순서를 받아 자료를 꺼낼 수 있는 것이다.

  * java.util.List
* Set 인터페이스는 중복을 허용하지 않는 인터페이스이다. 같은 값을 여러번 추가해도 마지막 값 하나만 저장된다.

  * Set 인터페이스에 저장되는 객체들은 Object가 가지고 있는 equals() 메소드와 hashCode() 메소드를 오버라이딩해야 한다.
  * java.util.Set
* Map 인터페이스는 key와 value로 구성된 인터페이스이다. ex) key:학번 value:학생

  * key는 유일하다. key들만 모아둔 것은 Set 자료구조가 된다. keySet이라는 메소드를 호출하면 key Set이 호출된다. 이 때 모든 키를 꺼내려면 순서가 없기 때문에 iterator()을 이용한다.


#### 제네릭을 사용하지 않고 ArrayList 사용하기

자료구조 객체들은 제네릭을 사용하지 않으면 자동으로 Object 타입을 지정한다.

```java
        ArrayList list = new ArrayList();
        list.add("kim");
        list.add("lee");

        String s1 = (String) list.get(0);
        String s2 = (String) list.get(1);

        System.out.println(s1);
        System.out.println(s2);
```


#### 제네릭을 사용한 ArrayList

```java
        ArrayList<String> list = new ArrayList<>();
        list.add("kim");
        list.add("lee");

        String s1 = list.get(0);
        String s2 = list.get(1);

        System.out.println(s1);
        System.out.println(s2);
```


#### Collection & iterator

`Collection<string> collection = new ArrayList<>();`

위 코드가 가능한 이유는 ArrayList는 List 인터페이스를 구현하고 있고, List 인터페이스는 Collection 인터페이스를 상속받고 있기 때문에 가능하다.

생성한 것은 ArrayList 인스턴스이지만 참조 타입을 Collection으로 선언했으므로 ArrayList의 메소드인 get() 메소드 같은 것들은 사용할 수 없고, Collection의 메소드인 add(), size(), iterator() 등만 사용 가능하다.


따라서 위의 collection 자료를 꺼내보려면 iterator() 메소드를 사용해야 한다.

```java
Iterator<String> iter = collection.iterator();
        while (iter.hasNext()) {
            String str = iter.next();
            System.out.println(str);
        }
```

실제로 위 코드를 실행해보면 넣어준 값들이 순서대로 나온다. 그런데 Collection 인터페이스는 순서를 기억하지 못한다고 했는데 왜 그럴까? 이유는 Collection을 구현하고 있는 것이 ArrayList이기 때문이다. 실제로 iterator() 메소드는 ArrayList 인스턴스인 collection이 오버라이딩해서 구현한 것이기 때문에 순서를 기억하고 있다.


만약 ArrayList가 아닌 HashSet이어도 에러가 발생하지 않는다. 마찬가지로 Collection을 상속받은 Set의 구현체이기 때문이다. 다만 Set은 순서를 기억하지 않기 때문에 랜덤 순서로 출력한다.


Collection을 구현하는 클래스들은 매우 많다.

`Collection<> collection = new ...;`

![image.png](assets/image_collection.png)

현실적으로 이 많은 클래스들의 사용법을 익히는 것보다 인터페이스 Collection의 사용법을 익히는 게 효율적이다. 

따라서 앞으론 어떤 인스턴스를 만들던 인스턴스를 사용하고자 하는 목적의 인터페이스 타입으로 참조하여 사용하도록 훈련해야 한다. 만약 HashSet을 사용하다가 더 좋은 성능의 클래스가 발견됐을 때 new로 시작하는 생성하는 코드만 바꿔주면 나머진 수정할 필요가 없어진다. 인터페이스 타입으로 프로그래밍하려고 노력하자.


### Set 인터페이스

```java
public class Set01 {
    public static void main(String[] args) {
        Set<MyData> mySet = new HashSet<>();
        mySet.add(new MyData("lee", 100));
        mySet.add(new MyData("kim", 200));
        mySet.add(new MyData("park", 300));
        mySet.add(new MyData("park", 300));

        Iterator<MyData> iterator = mySet.iterator();
        while (iterator.hasNext()) {
            MyData myData = iterator.next();
            System.out.println(myData);
        }
    }
}

// 불변객체
class MyData {
    private String name;
    private int value;

    public MyData(String name, int value) {
        this.name = name;
        this.value = value;
    }

    public String getName() {
        return name;
    }

    public int getValue() {
        return value;
    }

    @Override
    public String toString() {
        return "MyData{" +
                "name='" + name + '\'' +
                ", value=" + value +
                '}';
    }
}

```

[실행결과]

MyData{name='kim', value=200}
MyData{name='park', value=300}
MyData{name='park', value=300}
MyData{name='lee', value=100}



분명 Set 인터페이스는 중복을 허용하지 않는다고 했는데 `name='park', value=300` 데이터가 중복되어 들어갔다.

Set 인터페이스를 HashSet 클래스로 구현했다. HashSet에 A라는 자료를 저장하려고 하면 먼저 A 자료가 가지고 있는 hashCode() 메소드를 먼저 호출한다.

`A.hashCode()`

그럼 해시코드 값이 추출되는데 만약 그 값이 '가'라면 '가'라는 바구니에 그 자료를 넣는다. 마찬가지로 B 자료를 넣으려면 먼저 그 해쉬값인 '나' 바구니에 넣는다.

* 해쉬 코드 값이 같은 C 자료를 넣을 경우 : equals() 메소드를 통해 A 자료와 값을 비교한다. 같은 값을 가지고 있지 않을 경우에만 '가'바구니에 저장한다.
* 해쉬 코드 값이 같은 D 자료를 넣을 경우 : equals() 메소드를 통해 순차적으로 A 자료, C 자료와 값을 비교한다.
* A 자료를 또 넣을 경우 : equals() 메소드를 통해 순차적으로 A 자료, C 자료, D 자료와 값을 비교한다. A자료와 중복되므로 저장되지 않는다.

이렇게 순차적으로 비교하려면 속도가 매우 느려진다. 성능이 가장 좋게 나오려면 해쉬코드값 하나당 하나의 자료만 저장되어야 한다.


그런데 방금 만든 MyData는 왜 중복저장이 됐을까? MyData에는 equals()와 hashCode() 메소드를 정의하지 않았다. 따라서 최상위 부모인 Object 것을 사용하는데 Object의 equals()와 hashCode()는 아무런 검사도 안해줘서 소용이 없다. 그래서 반드시 hashSet()의 해시 알고리즘을 사용하려면 equals()와 hashCode()를 오버라이딩 해줘야 한다.


> 인텔리제이에는 control+enter 로 equals()와 hashCode()를 쉽게 만들 수 있게 해준다.

```java
@Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MyData myData = (MyData) o;
        return value == myData.value && Objects.equals(name, myData.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, value);
    }
```


### Map 인터페이스

Map의 key값도 당연히 유일해야 하므로 hash 알고리즘이 사용된다. key도 equals와 hashCode를 구현하고 있어야 하고, String 값이 key가 될 수 있는 이유는 String 객체도 equals와 hashCode를 구현하고 있기 때문이다.



* map의 put 메소드는 같은 키 값으로 자료를 넣으면 이전 값이 업데이트된다. (덮어쓰기)

```java
        map.put("c", "300");
        map.put("c", "수정값");
```


* map의 모든 자료 출력하기

key들이 모인 것은 Set 자료구조인 keySet이다.

```java
        Set<String> keySet = map.keySet();
        Iterator<String> iterator = keySet.iterator();
        while (iterator.hasNext()) {
            String key = iterator.next();
            String value = map.get(key);

            System.out.println(key + " : " + value);
        }
```



### 정렬

배열을 정렬할 때에는 Arrays라는 클래스를 사용했다. 자료구조에서 유용한 메소드들을 모아놓은 클래스는 Collections가 있다.

> Collection 인터페이스와 구별하기


Collections 클래스의 sort 메소드를 이용해 List의 객체들을 정렬할 수 있다. 정렬이 되기 위해서는 Comparable 인터페이스를 구현하고 있는 객체만 가능하다. Comparable 인터페이스의 compareTo라는 메소드를 구현해줘야만 한다.

> List< String> list 의 경우 String은 이미 정렬을 위한 메소드를 가지고 있어서 sort가 가능했다.



* Collections.shuffle();
  * 자료들을 섞어주는 메소드. 출력할 때마다 순서가 다르게 나온다.
