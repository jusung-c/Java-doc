## 제네릭

무엇이든 담을 수 있는 상자를 만들어 보자.

```java
public class ObjectBox {
    private Object object;

    public void set(Object obj) {
        this.object = obj;
    }

    public Object get() {
        return this.object;
    }
}
```


Object 타입은 모든 타입의 조상이므로 무엇이든 담을 수 있는 상자에 적합하다. 다만 꺼내서 사용할 때에는 타입에 맞춰 변환해줘야 한다.

```java
        ObjectBox box = new ObjectBox();
        box.set("kim");
        String str = (String) box.get();
        System.out.println(str.toUpperCase());

        box.set(new Integer(5));
        Integer i = (Integer) box.get();
        System.out.println(i.intValue());
```


그러나 매번 이렇게 꺼낼때마다 형변환이 필요한 단점이 있다. 보통 Object를 받기보다는 특정 물품을 담는 상자를 만들때가 많기 때문에 더 범용적인 상자를 만들 필요가 있다. 제네릭을 사용하면 가능하다.

```java
public class GenericBox<T> {
    private T t;
  
    public void add(T obj) {
        this.t = obj;
    }

    public T getT() {
        return this.t;
    }
}
```

```java
    public static void main(String[] args) {
        GenericBox<String> genericBox = new GenericBox<>();
        genericBox.add("kim");
        String str = genericBox.getT();
        System.out.println(str.toUpperCase());

        // genericBox.add(new Integer(5)); String이 아니기 때문에 컴파일 오류 발생
    }
```

* T는 제네릭과 관련된 부분으로 T라는 이름의 제네릭 타입을 선언한다는 것을 의미한다.
* 제네릭은 클래스 이름 뒤나, 메소드의 리턴타입 앞에 붙을 수 있다.
* T는 Type의 약자이기에 쓰지만 꼭 T가 아니어도 된다.


#### 제네릭의 장점

* 정해진 타입만 사용하도록 강제할 수 있다.
* 컴파일 시 잘못된 타입의 값이 저장되는 것을 막을 수 있다.
* 매번 형변환해줄 필요가 없다.


### 컬렉션 프레임워크(Collection Framework)

* Java Collections Framework라고 불리는 Collections API는 Java 2부터 추가된 자료구조 클래스 패키지를 말한다.
* 자료(Data)를 다룰 때 반드시 필요한 클래스의 모음으로 꼭 숙지해야 한다.

![JAVA Collection Framework (1) - 컬렉션 프레임워크란?](https://hudi.blog/static/1bacac1babc556100455a8c64e7658da/e6c4b/2.png)


Collection 인터페이스는 자료를 다루기 때문에 자료를 추가하는 add 메소드를 가지고 있고, 그 자료의 크기를 알기 위한 size 메소드 등 여러 메소드들이 있다.

자료를 꺼내기 위해서는 2가지 기능이 필요하다. 하나는 꺼낼 자료가 있는 지 없는 지 확인하는 기능, 둘은 꺼내는 기능이다. 이 둘을 표한한 기능이 iterator 인터페이스이다. iterator은 boolean형을 리턴하는 hasNext라는 메소드를 가지고 있는데 꺼낼게 있으면 true 없으면 false를 반환한다. next()라는 메소드는 하나 꺼내는 메소드이다.

> 이터레이터는 디자인 패턴의 이름이기도 하다. 모든 것을 꺼내기 위한 패턴.


Collection 인터페이스는 자료를 담는 바구니라고 생각하면 좋다. 배열과 다르게 자료를 넣어도 순서를 알 수 없는 것이다. 그래서 컬렉션에 들어있는 것을 꺼내기 위해 iterator 메소드를 이용하는 것이다.


**Collection을 상속받은 인터페이스 -java.util.Collection**

* 상속받은 클래스들은 Collection이 가진 add(), size(), iterator() 등의 메소드를 가지고 있다.
* List 인터페이스는 마찬가지로 객체를 담아두기 위한 인터페이스인데 특별히 순서를 저장하는 인터페이스이다. 순서를 저장하기 때문에 배열처럼 get으로 순서를 받아 자료를 꺼낼 수 있는 것이다.

  * java.util.List
* Set 인터페이스는 중복을 허용하지 않는 인터페이스이다. 같은 값을 여러번 추가해도 마지막 값 하나만 저장된다.

  * Set 인터페이스에 저장되는 객체들은 Object가 가지고 있는 equals() 메소드와 hashCode() 메소드를 오버라이딩해야 한다.
  * java.util.Set
* Map 인터페이스는 key와 value로 구성된 인터페이스이다. ex) key:학번 value:학생

  * key는 유일하다. key들만 모아둔 것은 Set 자료구조가 된다. keySet이라는 메소드를 호출하면 key Set이 호출된다. 이 때 모든 키를 꺼내려면 순서가 없기 때문에 iterator()을 이용한다.


#### 제네릭을 사용하지 않고 ArrayList 사용하기

자료구조 객체들은 제네릭을 사용하지 않으면 자동으로 Object 타입을 지정한다.

```java
        ArrayList list = new ArrayList();
        list.add("kim");
        list.add("lee");

        String s1 = (String) list.get(0);
        String s2 = (String) list.get(1);

        System.out.println(s1);
        System.out.println(s2);
```


#### 제네릭을 사용한 ArrayList

```java
        ArrayList<String> list = new ArrayList<>();
        list.add("kim");
        list.add("lee");

        String s1 = list.get(0);
        String s2 = list.get(1);

        System.out.println(s1);
        System.out.println(s2);
```


#### Collection & iterator
