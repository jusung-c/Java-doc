## 부모가 될 수 없는 final 클래스

* 상속을 금지 시키려면 클래스를 정의할 때 final 키워드를 사용한다.
* `public final class 클래스명 { ... }`
* 대표적인 final 클래스가 String 클래스이다.

String은 불변객체이다.

```java
String s1 = "hello";
        String s2 = "hello";
        String s3 = new String("hello");
        String s4 = new String("hello");

        if(s1 == s2)
            System.out.println("1:" + s1 == s2);
        if(s1 == s3)
            System.out.println("2:" +s1 == s3);
        if(s3 == s4)
            System.out.println("3:" +s3 == s4);
```

[결과]

```java
1: true
```

String을 new로 생성하지 않은 경우는 상수로 취급한다. 그래서 s1과 s2는 같은 것을 참조해서 1번 케이스가 true가 나온 것이다. s3와 s4는 new로 생성했기 때문에 new는 매번 새롭게 메모리에 영역을 차지한다.

> ==는 값이 같냐를 물어보는 것이 아닌 같은 것을 참조하느냐? 이다. 값을 비교할 때에는 equals 메소드를 사용한다.

```java
// 값이 동일한 지를 비교할 때에는 equals
        if(s1.equals(s2))
            System.out.println("s1과 s2의 값이 같다.");
  
        String s = s1.toUpperCase();    // 대문자 변환 메소드
        System.out.println(s);
        System.out.println(s1);
```

[결과]

```java
s1과 s2의 값이 같다.
HELLO
hello
```

String은 불변객체이기 때문에 최초로 한번 생성되변 절대 자기 자신의 값을 변경하지 않는다. 따라서 s1은 계속 같은 값을 출력한다.

#### String이 불변객체인 이유?

1. 메모리 절약

Java 디자이너는 가장 많이 사용되는 데이터 타입이 String이라 가장 많은 메모리를 차지할 것을 예측했기 때문에 최적화를 위해 String Pool에 리터럴을 포함하여 String 객체를 공유하고, 일시적으로 생성된 String 객체를 줄여줬다.

> 리터럴이란 변수에 넣는 변하지 않는 데이터(값)을 의미한다.

이때 가변 객체는 공유가 불가능하기 때문에 공유를 위해 불변객체로 만든 것이다.

만약 String "hello"를 100번 출력한다고 생각해보자. String의 불변성이 없다면 String Pool을 통한 String 객체를 공유할 수 없게 되고, "hello" String 객체를 100개 만들게 되어 메모리 낭비를 하게 된다.

하지만 String이 불변객체이기 때문에 "hello" String 객체는 Heap 영역에 단 하나만 생성되어 공유된다.

2. 보안상의 이유

네트워크 연결 시 호스트 및 포트가 String으로 되어 있고, 파일이나 디렉토리 경로도 String으로 되어 있으며 DB 연결에 필요한 URL도 String으로 되어있다.

String이 불변하지 않다면 사용자는 시스템의 특정 파일에 대한 엑세스 권한을 얻은 후 Path의 변경이 가능하게 되어 보안상의 문제가 발생할 수 있다.

3. Hash

String은 HashMap, Hashtable 같은 해시 기반 컬렉션의 키로써 많이 사용되기 때문에 동일한 값으로 저장된 객체의 value를 검색할 수 있도록 불변한 것이 중요하다.

키로 지정된 String의 내용이 수정되면 삽입 및 검색 시 두 개의 다른 해시 코드를 생성하게 되므로 맵에서 값 객체를 잃게 될 것이다.

#### String과 비슷하지만 내부가 변하는 StringBuffer 클래스

StringBuffer 클래스는 객체의 공간이 부족해지는 경우 버퍼의 크기를 유연하게 늘려준다. (mutable. 가변)

String은 내부의 문자열을 수정할 수 없기에 수정하고 싶으면 새로운 문자열을 만들어 리턴해야 한다. 그래서 문자열을 합쳐주는 +와 같은 연산자를 많이 사용하면 할수록 객체 수가 늘어나 프로그램 성능이 저하된다.

따라서 문자열을 변경하는 작업이 많을 경우 String을 사용하는 것보다 StringBuffer 클래스를 사용하는 것이 좋다. String Buffer 클래스는 내부 Buffer에 문자열을 저장해두고 그 안에서 추가, 수정, 삭제 작업을 할 수 있도록 설계되어 있다.

> Buffer: 데이터를 임시로 저장하는 메모리

그러나 StringBuffer를 생성할 경우 buffer의 크기를 초기에 설정해야 하므로 생성 속도가 많이 느리다. 마찬가지로 문자열 수정 시에도 buffer의 크기를 조절하고 명칭을 변경해야 하는 내부적인 연산이 필요해서 많은 양의 문자열 수정이 아니라면 String 객체를 사용하는 것이 오히려 나을 수도 있다.

> 단순 조회 연산은 String 객체가 빠르다.

## 접근제한자

![title](https://po9357.github.io/assets/img/%EC%A0%91%EA%B7%BC%EC%A0%9C%ED%95%9C%EC%9E%90(Access%20Modifier).png)

private 클래스는 언제 사용할까? 메소드를 구조적으로 나누고 싶을 때!

메소드가 길어지면 구조를 파악하기 힘들다.

## 인터페이스

설계를 할 때에는 구현부터 하는 것이 아닌 무슨 기능을 만들어야 할 지 부터 고민해야 한다. 만들어야 할 기능들을 관련된 것끼리 묶을 후 이름을 지어줘서 응집도를 높인다.

요구사항에는 기능적 요구사항, 비기능적 요구사항이 있다.

* 기능적 요구사항: 회원가입 기능, 글쓰기 기능 ...
* 비기능적 요구사항: 첫 페이지 안에 최소 3초 안 보여주기, 인터넷 환경...

> 비기능적 요구사항을 맞춰 설계를 하려면 그 조건을 만족하는 아키텍쳐가 필요하다.

결론적으로 구현은 항상 나중이다. 뭘 구현해야하는 지부터 고민하고 설계해야 한다. 만들어야할 기능들을 묶어서 이름을 지어주는데 이걸 인터페이스라고 한다.

인터페이스: 기능들의 목록

```java
[public] interface 인터페이스이름 { ... }
```

* 인터페이스는 구현은 없고 선언만 존재한다.
* 모든 필드는 public static final이어야 하며, 모든 메소드는 public abstract이어야 한다. (final, abstract 생략시 자동으로 붙음)
* 자바8부터는 default와 static 메서드 선언도 가능하다.
* 추상메소드만 가지고 있기 때문에 추상클래스와 마찬가지로 new로 인스턴스를 생성할 수 없다. 그저 필요한 기능만 나열해둔 껍데기이다. 구현을 안해도 필요한 기능을 to-do-list처럼 적어둔 것 뿐이다.

[로또 기계 실습]

```java
/*
1. 1~45까지 써있는 Ball을 로또 기계에 넣는다.
2. 로또 기계에 있는 Ball들을 섞는다.
3. 섞인 Ball중 6개를 꺼낸다.
 */
public interface LottoMachine {
    public static int MAX_BALL_COUNT = 45;
    public static int RETURN_BALL_COUNT = 6;
  
    // 45개 Ball 받기
    public abstract void setBalls(Ball[] balls);

    // Ball 섞기
    public abstract void mix();

    // 6개 Ball 반호나
    public abstract Ball[] getBalls();
}

```

> 여기서 변수 앞 public static과 메소드 앞 abstract는 생략 가능하다.

Ball 객체는 숫자를 가지고 있고 이 숫자는 생성될 때 초기화되며 불변하다. 따라서 생성자에서 초기값을 넘겨서 필드를 초기화해주고 값을 리턴만 해주는 불변 객체로 설계해야 한다.

```java
// 생성자에서 초기값을 넘겨서 필드를 초기화해주고 값을 리턴만 해주는 것을 불변 객체라고 했다.
public class Ball {
    private int number;    // 외부에서 변경할 수 없도록 private

    // 공은 생성될 때부터 숫자를 가지고 태어나고 바뀌면 안된다. - 불변
    public Ball(int number) {
        this.number = number;
    }
  
    // 외부에 숫자를 알려주기 위해 getter 생성
    public int getNumber() {
        return number;
    }
}
```

LottoMachineImpl

```java
public class LottoMachineImpl implements LottoMachine {
    private Ball[] balls;
    @Override
    public void setBalls(Ball[] balls) {
        this.balls = balls;
    }

    @Override
    public void mix() {
        for (int i = 0; i < 10000; i++) {
            // Math.random()은 0.0 <= x <= 1.0
            int x1 = (int)(Math.random() * LottoMachine.MAX_BALL_COUNT);
            int x2 = (int)(Math.random() * LottoMachine.MAX_BALL_COUNT);
            if (x1 != x2) {
                Ball tmp = balls[x1];
                balls[x1] = balls[x2];
                balls[x2] = tmp;
            } // if
        } // for
    }

    @Override
    public Ball[] getBalls() {
        Ball[] result = new Ball[LottoMachine.RETURN_BALL_COUNT];
        for (int i = 0; i < LottoMachine.RETURN_BALL_COUNT; i++) {
            result[i] = balls[i];
        }
        return result;
    }
}

```

Main 클래스

```java
public class LottoMachineMain {
    public static void main(String[] args) {
        // Ball 인스턴스를 45개 참조할 수 있는 배열 생성
        // 아직 Ball 인스턴스를 생성한 것이 아닌 Ball을 참조할 수 있는 참조변수 45개를 만든 것이다.
        Ball[] balls = new Ball[LottoMachine.MAX_BALL_COUNT];
        for (int i = 0; i < LottoMachine.MAX_BALL_COUNT; i++) {
            balls[i] = new Ball(i + 1);
        }

        // LottoMachine 인스턴스 생성
        LottoMachine lottoMachine = new LottoMachineImpl();
        lottoMachine.setBalls(balls);
        lottoMachine.mix();
        Ball[] result = lottoMachine.getBalls();

        // 당첨 공번호 출력
        for (int i = 0; i < result.length; i++) {
            System.out.println(result[i].getNumber());
        }
    }
}

```
