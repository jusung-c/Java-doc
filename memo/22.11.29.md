## 부모가 될 수 없는 final 클래스

* 상속을 금지 시키려면 클래스를 정의할 때 final 키워드를 사용한다.
* `public final class 클래스명 { ... }`
* 대표적인 final 클래스가 String 클래스이다.

String은 불변객체이다.

```java
String s1 = "hello";
        String s2 = "hello";
        String s3 = new String("hello");
        String s4 = new String("hello");

        if(s1 == s2)
            System.out.println("1:" + s1 == s2);
        if(s1 == s3)
            System.out.println("2:" +s1 == s3);
        if(s3 == s4)
            System.out.println("3:" +s3 == s4);
```

[결과]

```java
1: true
```

String을 new로 생성하지 않은 경우는 상수로 취급한다. 그래서 s1과 s2는 같은 것을 참조해서 1번 케이스가 true가 나온 것이다. s3와 s4는 new로 생성했기 때문에 new는 매번 새롭게 메모리에 영역을 차지한다.

> ==는 값이 같냐를 물어보는 것이 아닌 같은 것을 참조하느냐? 이다. 값을 비교할 때에는 equals 메소드를 사용한다.

```java
// 값이 동일한 지를 비교할 때에는 equals
        if(s1.equals(s2))
            System.out.println("s1과 s2의 값이 같다.");
  
        String s = s1.toUpperCase();    // 대문자 변환 메소드
        System.out.println(s);
        System.out.println(s1);
```

[결과]

```java
s1과 s2의 값이 같다.
HELLO
hello
```

String은 불변객체이기 때문에 최초로 한번 생성되변 절대 자기 자신의 값을 변경하지 않는다. 따라서 s1은 계속 같은 값을 출력한다.

#### String이 불변객체인 이유?

1. 메모리 절약

Java 디자이너는 가장 많이 사용되는 데이터 타입이 String이라 가장 많은 메모리를 차지할 것을 예측했기 때문에 최적화를 위해 String Pool에 리터럴을 포함하여 String 객체를 공유하고, 일시적으로 생성된 String 객체를 줄여줬다.

> 리터럴이란 변수에 넣는 변하지 않는 데이터(값)을 의미한다.

이때 가변 객체는 공유가 불가능하기 때문에 공유를 위해 불변객체로 만든 것이다.

만약 String "hello"를 100번 출력한다고 생각해보자. String의 불변성이 없다면 String Pool을 통한 String 객체를 공유할 수 없게 되고, "hello" String 객체를 100개 만들게 되어 메모리 낭비를 하게 된다.

하지만 String이 불변객체이기 때문에 "hello" String 객체는 Heap 영역에 단 하나만 생성되어 공유된다.

2. 보안상의 이유

네트워크 연결 시 호스트 및 포트가 String으로 되어 있고, 파일이나 디렉토리 경로도 String으로 되어 있으며 DB 연결에 필요한 URL도 String으로 되어있다.

String이 불변하지 않다면 사용자는 시스템의 특정 파일에 대한 엑세스 권한을 얻은 후 Path의 변경이 가능하게 되어 보안상의 문제가 발생할 수 있다.

3. Hash

String은 HashMap, Hashtable 같은 해시 기반 컬렉션의 키로써 많이 사용되기 때문에 동일한 값으로 저장된 객체의 value를 검색할 수 있도록 불변한 것이 중요하다.

키로 지정된 String의 내용이 수정되면 삽입 및 검색 시 두 개의 다른 해시 코드를 생성하게 되므로 맵에서 값 객체를 잃게 될 것이다.

#### String과 비슷하지만 내부가 변하는 StringBuffer 클래스

StringBuffer 클래스는 객체의 공간이 부족해지는 경우 버퍼의 크기를 유연하게 늘려준다. (mutable. 가변)

String은 내부의 문자열을 수정할 수 없기에 수정하고 싶으면 새로운 문자열을 만들어 리턴해야 한다. 그래서 문자열을 합쳐주는 +와 같은 연산자를 많이 사용하면 할수록 객체 수가 늘어나 프로그램 성능이 저하된다.

따라서 문자열을 변경하는 작업이 많을 경우 String을 사용하는 것보다 StringBuffer 클래스를 사용하는 것이 좋다. String Buffer 클래스는 내부 Buffer에 문자열을 저장해두고 그 안에서 추가, 수정, 삭제 작업을 할 수 있도록 설계되어 있다.

> Buffer: 데이터를 임시로 저장하는 메모리

그러나 StringBuffer를 생성할 경우 buffer의 크기를 초기에 설정해야 하므로 생성 속도가 많이 느리다. 마찬가지로 문자열 수정 시에도 buffer의 크기를 조절하고 명칭을 변경해야 하는 내부적인 연산이 필요해서 많은 양의 문자열 수정이 아니라면 String 객체를 사용하는 것이 오히려 나을 수도 있다.

> 단순 조회 연산은 String 객체가 빠르다.

## 접근제한자

![title](https://po9357.github.io/assets/img/%EC%A0%91%EA%B7%BC%EC%A0%9C%ED%95%9C%EC%9E%90(Access%20Modifier).png)

private 클래스는 언제 사용할까? 메소드를 구조적으로 나누고 싶을 때!

메소드가 길어지면 구조를 파악하기 힘들다.

## 인터페이스

설계를 할 때에는 구현부터 하는 것이 아닌 무슨 기능을 만들어야 할 지 부터 고민해야 한다. 만들어야 할 기능들을 관련된 것끼리 묶을 후 이름을 지어줘서 응집도를 높인다.

요구사항에는 기능적 요구사항, 비기능적 요구사항이 있다.

* 기능적 요구사항: 회원가입 기능, 글쓰기 기능 ...
* 비기능적 요구사항: 첫 페이지 안에 최소 3초 안 보여주기, 인터넷 환경...

> 비기능적 요구사항을 맞춰 설계를 하려면 그 조건을 만족하는 아키텍쳐가 필요하다.

결론적으로 구현은 항상 나중이다. 뭘 구현해야하는 지부터 고민하고 설계해야 한다. 만들어야할 기능들을 묶어서 이름을 지어주는데 이걸 인터페이스라고 한다.

인터페이스: 기능들의 목록

```java
[public] interface 인터페이스이름 { ... }
```

* 인터페이스는 구현은 없고 선언만 존재한다.
* 모든 필드는 public static final이어야 하며, 모든 메소드는 public abstract이어야 한다. (final, abstract 생략시 자동으로 붙음)
* 자바8부터는 default와 static 메서드 선언도 가능하다.
* 추상메소드만 가지고 있기 때문에 추상클래스와 마찬가지로 new로 인스턴스를 생성할 수 없다. 그저 필요한 기능만 나열해둔 껍데기이다. 구현을 안해도 필요한 기능을 to-do-list처럼 적어둔 것 뿐이다.

[로또 기계 실습]

```java
/*
1. 1~45까지 써있는 Ball을 로또 기계에 넣는다.
2. 로또 기계에 있는 Ball들을 섞는다.
3. 섞인 Ball중 6개를 꺼낸다.
 */
public interface LottoMachine {
    public static int MAX_BALL_COUNT = 45;
    public static int RETURN_BALL_COUNT = 6;
  
    // 45개 Ball 받기
    public abstract void setBalls(Ball[] balls);

    // Ball 섞기
    public abstract void mix();

    // 6개 Ball 반호나
    public abstract Ball[] getBalls();
}

```

> 여기서 변수 앞 public static과 메소드 앞 abstract는 생략 가능하다.

Ball 객체는 숫자를 가지고 있고 이 숫자는 생성될 때 초기화되며 불변하다. 따라서 생성자에서 초기값을 넘겨서 필드를 초기화해주고 값을 리턴만 해주는 불변 객체로 설계해야 한다.

```java
// 생성자에서 초기값을 넘겨서 필드를 초기화해주고 값을 리턴만 해주는 것을 불변 객체라고 했다.
public class Ball {
    private int number;    // 외부에서 변경할 수 없도록 private

    // 공은 생성될 때부터 숫자를 가지고 태어나고 바뀌면 안된다. - 불변
    public Ball(int number) {
        this.number = number;
    }
  
    // 외부에 숫자를 알려주기 위해 getter 생성
    public int getNumber() {
        return number;
    }
}
```

LottoMachineImpl

```java
public class LottoMachineImpl implements LottoMachine {
    private Ball[] balls;
    @Override
    public void setBalls(Ball[] balls) {
        this.balls = balls;
    }

    @Override
    public void mix() {
        for (int i = 0; i < 10000; i++) {
            // Math.random()은 0.0 <= x <= 1.0
            int x1 = (int)(Math.random() * LottoMachine.MAX_BALL_COUNT);
            int x2 = (int)(Math.random() * LottoMachine.MAX_BALL_COUNT);
            if (x1 != x2) {
                Ball tmp = balls[x1];
                balls[x1] = balls[x2];
                balls[x2] = tmp;
            } // if
        } // for
    }

    @Override
    public Ball[] getBalls() {
        Ball[] result = new Ball[LottoMachine.RETURN_BALL_COUNT];
        for (int i = 0; i < LottoMachine.RETURN_BALL_COUNT; i++) {
            result[i] = balls[i];
        }
        return result;
    }
}

```

Main 클래스

```java
public class LottoMachineMain {
    public static void main(String[] args) {
        // Ball 인스턴스를 45개 참조할 수 있는 배열 생성
        // 아직 Ball 인스턴스를 생성한 것이 아닌 Ball을 참조할 수 있는 참조변수 45개를 만든 것이다.
        Ball[] balls = new Ball[LottoMachine.MAX_BALL_COUNT];
        for (int i = 0; i < LottoMachine.MAX_BALL_COUNT; i++) {
            balls[i] = new Ball(i + 1);
        }

        // LottoMachine 인스턴스 생성
        LottoMachine lottoMachine = new LottoMachineImpl();
        lottoMachine.setBalls(balls);
        lottoMachine.mix();
        Ball[] result = lottoMachine.getBalls();

        // 당첨 공번호 출력
        for (int i = 0; i < result.length; i++) {
            System.out.println(result[i].getNumber());
        }
    }
}

```

### JDK 8부터 추가된 인터페이스의 default method

A라는 인터페이스가 2개의 메소드를 가지고 오픈소스로 공개되었다. 사람들이 이 인터페이스를 구현해서 클래스들을 구현했다. 그런데 A 인터페이스 개발자가 추가 기능이 필요하다고 판단해 메소드 하나를 추가하여 버전 업을 했다. A 인터페이스를 사용한 사람들도 같이 버전업했을 경우 잘 동작하던 클래스들이 추가된 메소드 때문에  에러가 발생할 것이다.

A 인터페이스에 메소드 하나 추가했을 뿐인데 A 인터페이스를 구현한 수많은 클래스들이 다 먹통이 되는 문제가 발생한다. 이런 경우를 대비해 Java 8부터 기능이 추가됐다. A 인터페이스에 나중에 추가한 메소드를 default 메소드로 구현할 수 있게 했다. 인터페이스는 원래 메소드를 선언만 할 수 있었는데 구현까지 가능해진 것이다. 이러면 버전업이 되더라도 추가된 메소드는 그냥 상속받듯이 구현한 클래스들이 사용할 수 있게 된다. 원한다면 메소드 오버라이딩까지 가능해졌다.

### JDK 8부터 추가된 인터페이스의 static method

인터페이스를 구현한 클래스가 없어도 사용가능한 static method가 추가됐다. 인터페이스를 구현한 클래스가 없더라도 (인터페이스명).(static method명)으로 사용 가능해졌다.

## 팩토리 메소드 패턴

공장이 하는 일은 복잡한 생산 과정을 거치고 제품을 생산하는 것이다. 사용자 입장에서 그 공장이 어떤 생산 과정을 거치는 지 몰라도 결과만 받아 이용하면 된다. 이렇게 객체의 생성되는 과정을 숨겨주는 패턴을 팩토리 메소드 패턴이라고 한다.

기존에는 `Bus b1 = new Bus();` 로 Bus 인스턴스를 생성했는데 팩토리 메소드 패턴을 통해 다음과 같이 생성 과정을 숨기고 생성할 수도 있다. 생성 과정을 BeanFactory에 맡겨서 생성한 예이다.

```java
public class BeanFactory {
    // 2. 자기 자신 인스턴스 참조하는 static한 필드 선언.
    private static BeanFactory instance = new BeanFactory();

    // 1. private 생성자. 외부에서 인스턴스 생성 불가
    public BeanFactory() {
    }

    // 3. 2번에서 생성한 인스턴스를 반환하는 static한 메소드 생성
    public static BeanFactory getInstance() {
        return instance;
    }

    public Bus getBus() {
        return new Bus();
    }
}

```

```java
public class BeanFactoryMain {
    public static void main(String[] args) {
        BeanFactory bf1 = BeanFactory.getInstance();

        Bus b1 = bf1.getBus();
        Bus b2 = bf1.getBus();

    }
}

```

## 클래스 로더를 이용해 인스턴스 생성

인스턴스를 생성할 때 new 명령어를 이용해 만들었는데 클래스 로더를 이용해서도 생성할 수 있다.

```java
Class clazz = Class.forName("클래스풀네임");
Object obj = clazz.newInstance();
```

[가정]

1. Bus와 SuperCar 클래스 모두 a() 메소드를 가지고 있다
2. a() 메소드를 실행할 수 있도록 코드를 작성해야 하는데 아직 어떤 클래스인지 모른다.
3. 이 클래스 이름은 나중에 알게 될 것이다.
4. a() 메소드를 실행할 수 있도록 코드를 작성해야 한다.

이럴때 사용하는 것이 클래스로더이다.

JVM은 클래스를 CLASSPATH에서 찾는다고 했다. `Class.forName("클래스이름")`은 클래스명으로 바로 썼으니까 static한 메소드인데 클래스이름에 해당되는 클래스를 CLASSPATH에서 읽어들인다.

```java
String className = "practice.Bus";
Class clazz = Class.forName(className);
Method[] declaredMethods = clazz.getDeclaredMethods();
for (Method m : declaredMethods) {
    System.out.println(m.getName());
}
```

[결과]

```java
b
c
a
```

clazz는 forName으로 찾은 클래스를 가리킨다. getDeclaredMethods()로 가지고 있는 메소드들을 하나씩 꺼내서 출력해준 것이다.

```java
        String className = "practice.Bus";
        Class clazz = Class.forName(className);
        Object o = clazz.newInstance();
  
        Bus b = (Bus) o;
        b.a();
```

위부터 세줄의 코드는 `Object o = new Bus();` 와 같은 코드이다.

만약 여기서 className을 SuperCar로 바꿔준다면 Bus로 형변환하는 과정에서 ClassCastException이 발생할 것이다.

만약 두 클래스의 a() 메소드를 전부 사용하고 싶다면 두 클래스의 부모인 Car 클래스를 만들고 상속받게 해서 o를 Car 타입으로 형변환을 해주면 된다.

```
Car b = (Car) o;
````

이러면 클래스 이름이 어떻게 되던 부모 타입으로 생성하므로 에러없이 사용 가능하다.

이번엔 Car를 상속받지 않은 상관없는 메소드 Hi의 a() 메소드를 실행해보자

```java
        String className = "practice.Hi";
        Class clazz = Class.forName(className);
        Object o = clazz.newInstance();

        // a() 메소드 정보를 가지고 있는 Method 반환
        Method m = clazz.getDeclaredMethod("a", null);
        // Object o가 참조하는 객체의 m 메소드를 실행
        m.invoke(o, null);
```

className을 Bus나 SuperCar로 바꿔줘도 잘 실행된다.

**이 과정을 통해 얻을 수 있는 사실은 문자열로 된 클래스명과 문자열로 된 메소드명만 가지고도 표현할 수 있는 방법이 있다는 것이다! 나중에 서블릿이나 스프링에서 내부적으로 사용하는 기술이다.**
