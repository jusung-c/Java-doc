## 상속

OO는 OO다. OO는 OO의 종류 중 하나다. 라고 표현할 수 있다면 이것은 상속이다.

* 일반화시키기 (여러 종류의 객체를 하나의 이름으로 부를 수 있는 것)
  * TV는 전자제품이다.
  * 세탁기는 전자제품이다.
* 전자제품을 상속받은 TV, 세탁기는 모두 끄다(), 켜다() 메소드를 가진다.

상속 = 일반화 + 확장

* 부모클래스를 상속받는다는 것은 부모가 가진 것을 자식이 물려받아 사용할 수 있다는 것
* 좋은 객체란 응집도는 높이고 결합도는 낮추는 것이라 했는데 상속은 굉장히 강한 결합이므로 잘못 상속받으면 타격이 너무 크기에 반드시 써야만 할 때에 사용해야 한다.
* 최대한 상속을 쓰지 않도록 하자..!

#### 아무것도 상속받지 않으면 자동으로 java.lang.Object를 상속받는다

모든 클래스는 Object의 자손이다.(최상위 클래스)

## 다형성 - 메소드 오버라이딩(Overriding)

* 상위 클래스의 메서드를 하위 클래스가 재정의하는 것
* 메소드의 이름, 파라미터의 갯수, 타입이 동일해야 한다.

#### 메소드가 오버라이딩 되면 무조건 자식의 메소드가 실행된다!

```java
public class Car {
    public void run() {
        System.out.println("전륜구동");
    }
}
```

```java
public class Bus extends Car {
    @Override
    public void run() {
        System.out.println("후륜구동");
    }
}
```

```java
 public static void main(String[] args) {
        Bus b1 = new Bus();
        b1.run();

        Car c1 = new Car();
        c1.run();   

        Car c2 = new Bus();
        c2.run();   // 메소드가 오버라이딩되면 무조건 자식 메소드 실행!
    }
```

[실행결과]

```java
후륜구동
전륜구동
후륜구동
```

`Car c1 = new Bus();` 참조 타입을 Car로 하고 Bus 인스턴스를 생성했을 경우 Car 타입의 메소드인 run()만 사용이 가능하고 Bus의 다른 추가적인 메소드는 사용 불가능하다. 만약 사용하고 싶으면 다음과 같이 타입을 바꿔줘야 한다.

```java
Car c1 = new Bus();
c1.run()
Bus b1 = (Bus)c1;
b1.안내방송();
```

이것이 가능한 이유는 c1이 참조하는 것이 Bus 인스턴스이기 때문에 이걸 Bus 타입으로 변환해서 b1이 참조하게 했기 때문이다.

## 필드, 메소드 오버라이딩 시 주의점

필드는 Type을 따라가고 메소드는 오버라이딩된 자식의 메소드가 실행된다!

```java
public class Parent {
    int i = 5;
    public void printII() {
        System.out.println(i * 2);
    }
    public void printI() {
        System.out.println("parent - printI(): " + i);
    }
}

```

```java
public class Child extends Parent {
    public int i = 15;      // 필드 오버라이딩
    public void printI() {      // 메소드 오버라이딩
        System.out.println("child - printI(): " + i);
    }
}
```

```java

public static void main(String[] args) {
        Parent p1 = new Parent();
        System.out.println(p1.i);
        p1.printI();
        p1.printII();

        System.out.println("-------------------------");
        Child c1 = new Child();
        System.out.println(c1.i);
        c1.printI();
        c1.printII();

        System.out.println("-------------------------");
        Parent p2 = new Child();
        System.out.println(p2.i);       // 필드는 타입을 따라가고
        p2.printI();                    // 메소드는 자식 메소드를 따라간다
        p2.printII();
    }
```

[실행결과]

```java
5
parent - printI(): 5
10
-------------------------
15
child - printI(): 15
10
-------------------------
5
child - printI(): 15
10
```

#### 정보 은닉(information hiding)은 객체지향의 중요한 기법이다. 중요한 필드는 은닉해서 외부에서 직접 접근할 수 없도록 하고, 필드는 메소드를 통해서만 접근해서 사용하도록 코딩해야 한다.

* 위 코드의 경우 `System.out.println(c1.i);` 같은 코드가 필드에 직접 접근하는 코드이므로 좋지 않다.

## Getter & Setter 프로퍼티

private로 필드를 은닉화했을 때 이 필드의 값을 수정하고 얻기 위해 Getter, Setter 메소드를 사용한다.

```java
public class Book {
    private String title;   // field price
    private int price;

    // setter, getter - 프로퍼티(property)
    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }
}

```

* getter, setter는 프로퍼티이다. 위 코드에서는 title 프로퍼티, price 프로퍼티 총 2개의 프로퍼티가 존재

> this는 내 자신 인스턴스를 참조하는 예약어로 클래스 메소드에서는 사용이 불가능하다.(메모리에 생성되는 시점이 다르므로)

## 오버라이딩하라고 만든 Object의 메소드

Object가 오버라이딩하라고 제공하는 메소드

* toString()
* equals() & hashCode()

```java
    public static void main(String[] args) {
        Car c1 = new Car();
        System.out.println(c1); 
    }
```

[실행결과]

`Car@7c75222b`

Syste.out의 println 메소드들을 보면 print(Object x)가 있다. 위의 경우 Object 인자를 받아 출력한 경우이다. 부모타입의 변수로 자식 인스턴스를 참조할 수 있고, 조상 타입의 변수로도 후손 인스턴스를 참조할 수 있다고 했었다. Object는 모든 클래스의 조상이므로 가능한 것이다.

```java
public class PrintStream extends FilterOutputStream
    implements Appendable, Closeable
{
    ...

    public void println(Object x) {
        String s = String.valueOf(x);
        synchronized (this) {
            print(s);
            newLine();
        }
    }

    ...
}
```

실제로 println(Object x) 코드를 까보면 Object x를 받아서 문자열로 만들어준 후 문자열을 받는 print()로 넣어준다.

valueOf()를 또 따라 들어가 보면 obj가 null이면 "null"을 아니면 obj의 toString() 값을 리턴해주고 있다.

```java
public static String valueOf(Object obj) {
        return (obj == null) ? "null" : obj.toString();
    }
```

즉, println(Obejct x)는 Object x의 toString()값을 출력해주는 것이다.

toString()을 오버라이딩 해주면 원하는 출력 형태로 출력할 수 있게 된다.

#### equals 메소드는 값을 비교하는 기준이 필요하기 때문에 오버라이딩이 필요하다.

> hashCode()
>
> * hash 코드를 만들어내는 기능
> * 값이 같은지 비교하는 기능

## 생성자

* 인스턴스를 생성할 때 사용
* 리턴타입 없이 클래스와 같은 이름으로 생성
* 클래스 작성 시 생성자를 하나도 만들지 않으면 자동으로 기본 생성자 생성
  * 기본생성자 : 매개변수를 하나도 받지 않는 생성자

이름을 가지고 인스턴스가 만들어지도록 하려면 다음과 같이 생성자를 만들어줘야 한다.

```java
private String name;    // 필드

public Car(String name) {
    this.name = name;    // 인스턴스의 필드(이름)을 전달받은 name으로 설정
}
```

이제는 생성자를 만들어줬기 때문에 기본생성자는 만들어지지 않는다. 따라서 다음 코드는 에러가 발생한다.

```java
Car c1 = new Car();
```

> 불변객체란?
>
> 생성자에서 넣어준 값(은닉화된 값)을 반환해주는 즉, getter 기능만 가지고 있는 객체를 불변 객체라고 한다. 객체를 생성할 때 값을 가지게 한 후 외부에 전달할 때 사용한다. 누군가가 그 객체의 값을 바꾸지 못하도록 할 수 있는 것이다.
>
> 대표적인 불변객체: String - 문자열이 불변객체라는 것은 String이 가지고 있는 모든 메소드는 String 내부의 값을 변화시키지 않는다.

#### 생성자가 여러개인 경우 - 생성자 오버로딩

```java
public class Person {
    private String name;
    private String email;
    private String password;

    public Person(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public Person(String name, String email, String password) {
        this.name = name;
        this.email = email;
        this.password = password;
    }
}

```

생성자가 여러개인 경우 생성자 오버로딩을 통해 선언하면 된다. 생성자는 매개변수의 개수가 다르거나, 타입이 다르다면 여러개를 가질 수 있다.

> 여러개를 만들면 만드는 사람은 힘들지만 쓰는 사람은 편리하기에 클래스를 만들 때는 사용하는 사람 입장에서 만들어야 한다.

그런데 보면 중복되는 코드가 생긴다. 이 코드를 줄이기 위해 생성자 안에서 자기 자신을 호출할 수 있다.

```java
public class Person {
    private String name;
    private String email;
    private String password;

    public Person(String name, String email) {
        this(name, email, null);    // 자신의 생성자를 호출해서 중복 제거
    }

    public Person(String name, String email, String password) {
        this.name = name;
        this.email = email;
        this.password = password;
    }
}
```

파라미터를 많이 받는 생성자를 this로 호출해야 편리해진다!

#### this 생성자

* 인스턴스 자기 자신을 참조할 때 사용하는 키워드
* this() 생성자는 자기 자신의 생성자를 뜻한다.
* this() 생성자는 생성자 안에서만 사용 가능하고, super() 생성자를 호출하는 코드 다음이나, 맨 첫번째 줄에 위치해야 에러가 나지 않는다.

### 생성자 super() - 부모의 생성자 호출

* 인스턴스 부모를 참조할 때 사용
* super() 생성자는 부모 생성자를 의미하고, 생성자 안에서만 사용 가능하고 첫번째 줄에만 올 수 있다.
* 생성자는 무조건 super() 생성자를 호출해야 한다. 사용자가 super() 생성자를 호출하는 코드를 작성하지 않았다면 자동으로 부모의 기본 생성자가 호출된다.
* 부모클래스가 기본 생성자를 가지고 있지 않다면, 사용자는 반드시 직접 super() 생성자를 호출해야 한다.

```java
public class Car {
    public Car() {
        System.out.println("Car() 생성자 호출");
    }
}

public class Bus extends Car {
    public Bus() {
    }
}
```

```java
public static void main(String[] args) {
        Car c1 = new Car();

        Bus b1 = new Bus();
    }
```

[결과]

```java
Car() 생성자 호출
Car() 생성자 호출
```

Bus() 생성자를 호출해도 Car()이 호출된다. 이유는 자식 클래스인 Bus의 생성자는 자동으로 부모 클래스의 생성자인 super()를 호출하기 때문이다.

```java
public class Car {
    public Car() {
        // super();    // 자동으로 들어간다.
        System.out.println("Car() 생성자 호출");
    }
}

public class Bus extends Car {
    public Bus() {
        // super();    // 자동으로 들어간다.
    }
}
```

여기서 Bus클래스의 생성자에 다른 출력 코드를 추가하면 어떻게 될까?

```java
public class Bus extends Car {
    public Bus() {
        // super();    자동으로 들어간다.
        System.out.println("Bus 생성자 호출"):
    }
}
```

[결과]

```java
Car() 생성자 호출
Car() 생성자 호출
Bus 생성자 호출
```

부모 생성자 호출 코드인 super() 코드가 먼저 실행되고 다음 출력 코드가 실행된다.

만약 부모 클래스의 생성자가 기본생성자가 아니라 name을 받는 생성자라면 자식 클래스인 Bus 클래스에서 꼭 super() 생성자를 호출해줘야 한다.

```java
public class Car {
    public Car(String name) {
        System.out.println("Car() 생성자 호출: " + name);
    }
}

public class Bus extends Car {
    public Bus() {
        super("자동차");
        System.out.println("Bus 생성자 호출");
    }
}
```

[결과]

```java
Car() 생성자 호출: 차
Car() 생성자 호출: 자동차
Bus 생성자 호출
```
