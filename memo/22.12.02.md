## 배열

* 참조 타입
* 같은 타입의 변수가 여러 개 필요할 때 사용
* 기본형 배열: boolean, byte, short, char, int, long, float, double 타입의 변수를 여러개 선언할 필요가 있을 때 사용
* 참조형 배열: 배열 자체도 참조형인데 가지는 값도 참조형인 배열

**불변객체 ItemForArray를 초기화하는 방법**

```java
ItemForArray[] arr = new ItemForArray[2];
arr[0] = new ItemForArray(500, "item01");

arr[0].getName();
```

여기서 초기화가 안된 arr[1].getName()이나 arr[1].length같은 메소드를 사용하면 참조하는 값이 없기 때문에 NullPorinterException이 발생한다.

## 이차원 가변 배열의 선언과 초기화

`타입[][] 변수명 = new 타입[행의수][];`

`변수명[행의인덱스] new 타입[열의수];`

3개의 반의 각각 다른 학생수의 점수를 나타낸 배열

```java
int[][] score = new int[3][];
score[0] = new int[20];
score[1] = new int[19];
score[2] = new int[21];
```

**가변 이차원 배열 출력**

```java
for(int i=0; i<score.length; i++) {
    for(int j=0; score[i].length; j++) {
        System.out.print(score[i][j] + "\t");
    }
    System.out.println();
}
```

# Arrays 라이브러리

java.util 패키지에 포함된 자바가 제공하는 라이브러리이다.

java api의 Arrays 클래스를 보면 제공하는 메소드 전부 static이 붙어있다. 따라서 인스턴스를 생성해서 사용하는 게 아닌 클래스명.메소드명 으로 사용하면 된다.

#### Arrays.copyOf

```java
        int[] From = {1, 2, 3};

        int[] To1 = Arrays.copyOf(From, From.length);
        for (int c : To1) {
            System.out.println(c);
        }

        if (From == To1) {
            System.out.println("From == To1");
        } else {
            System.out.println("From != To1");
        }

        System.out.println("-------------------");
  
        int[] To2 = From;
        if (From == To2) {
            System.out.println("From == To2");
        } else {
            System.out.println("From != To2");
        }
```

[결과]

```java
1
2
3
From != To1
-------------------
From == To2
```

참조 타입끼리의 ==연산자는 같은 것을 참조하는 지 확인한다고 했다. To2는 변수명만 다르게 From이 참조하는 것과 같은 것을 참조하도록 한 것이고 To1은 Arrays.copyOf로 새로운 배열을 만들어 복사하여 참조하게 한 것이므로 From과 다른 것이다.

> 배열을 복사한다는 것과 같은 배열을 참조한다는 것의 차이점 알기!

#### 깊은 복사(Deep Copy) vs 얕은 복사(Shallow Copy)

깊은 복사(Deep Copy)는 '실제 값'을 새로운 메모리 공간에 복사하는 것을 의미한다. 깊은 복사를 구현하는 방법은 Cloneable 인터페이스 구현, 복사 팩터리 등 여러 방법이 있다.

![](https://blog.kakaocdn.net/dn/bLG1ht/btraPuYy2Oy/PfHI6w3v7XGUKwOvDpgKqk/img.png)

얕은 복사(Shallow Copy)는 '주소 값'을 복사한다는 의미이다. 주소 값을 복사하기 때문에 참조하고 있는 실제값은 같다.

```java
Car c1 = new Car();
Car c2 = c1; // 얕은 복사
```

여기서 c1 객체의 값을 변경하면 c2 객체값도 변경된다. 주소 값을 복사했기 때문에 복사한 객체가 변경되면 기존 객체도 마찬가지로 변경된다.

![](https://blog.kakaocdn.net/dn/cIKEl2/btraRxtGojp/YOAGEZkyXLAZDjem2FYink/img.png)

#### Arrays.copyOfRange

범위를 지정해서 복사도 가능하다.

```java
char[] From = {'h', 'e', 'l', 'l', 'o', '!'};
        char[] To = Arrays.copyOfRange(From, 1, 3);

        for (char c : To) {
            System.out.println(c);
        }
```

[결과]

```java
e
l

```

#### Arrays.compare

배열 비교 메소드

양수, 0, 음수 중 하나로 결과값을 반환한다.

```java
Arrays.compare(x, y);
```

x-y의 결과라고 생각하면 된다.

* 양수: x>y
* 0: x=y
* 음수: x<y

원소의 개수가 더 많을수록, 같다면 더 큰 수를 가질수록 큰 배열이다.

#### Arrays.sort

배열 정렬 메소드

```java
Arrays.sort(arr);
```

#### Arrays.binarySearch

배열 검색 메소드로 정렬된 배열에서 key값의 인덱스값을 찾아준다.

up&down 게임에서 가장 빨리 찾는 방법은 이분탐색법 즉 binarySearch이다.

```java
Arrays.sort(arr);

Arrays.binarySearch(arr, 4);
```

### Comparable

객체들의 배열을 Arrays.sort로 정렬해보면 ClassCastException이 발생한다. 왜 그럴까?

정렬을 한다는 것은 비교를 할 수 있어야 한다. 그런데 객체들의 배열은 비교 기준이 세워져있지 않다. Comparable 인터페이스로 기준을 세워줘야 한다.

```java
// Comparable은 어떤 Item이 큰지, 작은지 기준을 정하는 Interface
class Item implements Comparable {
    private String name;
    private int price;

    ...

    @Override
    public String toString() {
        return "Item{" +
                "name='" + name + '\'' +
                ", price=" + price +
                '}';
    }

    // 파라미터로 들어온 Object와 내 자신을 비교하는 메소드
    // compareTo에는 Obejct를 받아들이도록 했지만 실제로는 Item이 들어온다.
    @Override
    public int compareTo(Object o) {
        Item d = (Item) o;
  
        // String도 compareTo 메소드 가지고 있다!
        return this.name.compareTo(d.name);  // 비교할땐 양수, 0, 음수 생각하기!
    }
}
```

정렬해보면 가나다 순으로 비교해서 결과를 반환한다. 홍길동 > 고길동

만약 객체들의 이름이 아닌 가격으로 비교를 하고 싶다면 다음과 같이 compareTo를 오버라이딩하면 된다.

```java
@Override
    public int compareTo(Object o) {
        Item d = (Item) o;
        return this.price - d.price;
    }
```

자신의 가격과 들어온 가격과 비교해서 결과를 반환한다. 정렬해보면 가격별로 오름차순으로 정렬되는 것을 볼 수 있다.

어쩔땐 이름, 어쩔땐 가격으로 비교하고 싶을 때 매번 이렇게 compareTo 코드를 바꾸긴 번거롭다. 이런 문제를 Comparator로 해결할 수 있다.

```java
class ItemSorter implements Comparator {

    // o1 - o2 양수, 음수, 0
    @Override
    public int compare(Object o1, Object o2) {
        Item i1 = (Item) o1; 
        Item i2 = (Item) o2;
        return i1.getName().compareTo(i2.getName());
    }
}


Arrays.sort(items, new ItemSorter());
```

이렇게 외부에서 정렬기준을 정해줄 수도 있다.

또한 이 인터페이스는 메소드 하나만 존재하기 때문에 이름 없는 람다 인터페이스로도 구현 가능하다.

```java
Arrays.sort(items, new Comparator(){
            @Override
            public int compare(Object o1, Object o2) {
                Item i1 = (Item) o1;
                Item i2 = (Item) o2;
                return i1.getName().compareTo(i2.getName());
            }
        });
```

```java
Arrays.sort(items, (i1, i2) -> i1.getName().compareTo(i2.getName()));
```

### 명령 행 아규먼트(Command-Line Arguments)

* main 메소드의 String[] args
* main 메소드는 JVM이 자동으로 실행해주는데 이 때 String[]을 아규먼트로 넘겨 준다는 것을 의미한다.

```java
public static void main(String[] args) {
        System.out.println(args.length);
    }
```

결과는 0이 나온다. 다음 과정이 일어난 것이다.

```java
String[] args = new String[0];
main(args);
```

인텔리제이가 아닌 커맨드창으로 자바파일 실행하는 방법을 기억해보자

```java
javac Car.java
java Car
```

여기에서 `java Car`를 실행할 때 뒤에 a b c d e를 적어주면 이게 아규먼트들이 된다. 5개의 문자열 배열이 args로 들어오게 되는 것이다. 이렇게 하고 args의 길이를 출력해보면 5가 나오는 것을 볼 수 있다.

인텔리제이에서도 설정을 통해 a b c d e 인자를 넣어주면 다음과 같이 클래스명 뒤에 나열된다.

`java -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=54562:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/jus/dev/JAVA/out/production/JAVA practice.MyRunnableMain a b c d e`

> 여기에서 클래스명과 java 사이의 `-javaagent:.....`부분은 JVM에 주는 옵션이다.


a b "hello world"로 인자를 전달하면 문자열이기 때문에 3개의 인자가 전달된 것이다.

* a
* b
* hello world


#### System.exit

System.exit는 프로그램을 종료시키는 메소드다. return;으로 변경 가능하다.

```java
System.exit(0);
```

exit의 status가 0이라는 것은 뭘 의미할까? 명령어를 실행했을 때 성공 시 아무런 메세지도 출력하지 않는다. 이것은 Unix와 Linux의 철학이다. 이것들은 작은 명령들을 조합해서 또 다른 명령을 만드는 즉, 쉘 스크립트를 작성한다.

작은 명령들이 실행되고 종료될 때 성공 유무를 알기 위해 조건문을 사용하는데 이 때 사용되는 것이 exit의 인자로 오는 status 값이다. 종료 코드를 리턴해주는 것이다.

리눅스 공부 필요...


### 제한없는 아규먼트 (unlimited arguments)

* 경우에 따라 메소드 아규먼트를 가변적으로 전달하고 싶을 때

```java
public class MyRunnableMain {
    public static void main(String[] args) {
        System.out.println(sum(5, 2, 3));
        System.out.println(sum(5, 3, 4, 2, 1));
    }

    private static int sum(int... args) {
        System.out.println("args 길이: " + args.length);
        int sum = 0;

        for (int i = 0; i < args.length; i++) {
            sum += args[i];
        }

        return sum;
    }
}

```

`int... args` 에서 ...은 정수를 여러개 받을 수 있다는 의미로 가변길이의 아규먼트를 받는다.
