## 추상클래스

* 인스턴스가 될 수 없는 클래스로 상속받는 자손이 인스턴스가 된다.
* abstract 키워드를 사용하여 클래스를 정의하고, 보통 1개 이상의 추상 메소드를 가진다.
  * `public abstract class 클래스명 { ... }`

추상 클래스 Car는 run() 메소드가 필요하다. 이 run()를 자동차마다 다르게 구현해야 할 때 추상메소드를 사용하면 된다.

```java
public abstract class Car {
    public Car(String name) {
        System.out.println("name: " + name);
    }

    public abstract void run();
}
```

이렇게 추상메소드로 만들어두면 Car 클래스를 상속받은 자식 클래스들은 필수적으로 부모클래스가 가진 추상메소드를 오버라이딩해야 한다. 당연히 부모의 기본 생성자가 없기 때문에 반드시 super()를 호출해줘야 한다.

```java
public class Bus extends Car {
    public Bus() {
        super("Bus!!");
    }

    @Override
    public void run() {
        System.out.println("버스 run");
    }
}

public class Taxi extends Car {
    public Taxi(String name) {
        super(name);
    }

    @Override
    public void run() {
        System.out.println("택시 run");
    }
}
```


그렇다면 만약 `Car c = new .....;` ....부분의 코드를 가려져있다고 가정하고 c.run();을 하면 어떤 결과가 나올까?

Car는 추상클래스이기 때문에 `Car c = new Car();` 이 불가능하다. Car의 자식클래스인 Bus나 Taxi만 가능할 것이다. 따라서 어떤 인스턴스냐에 따라 run()메소드가 다른 결과를 나타낼 것이다. 컴파일러가 ...부분의 코드를 모른다면 실행되기 전까지는 run 메소드의 결과를 알 수 없다. 

> 이렇게 자바처럼 실행한 후에 결과를 알 수 있는 언어를 동적인 언어라고 한다.

```java
Car[] arr = new Car[2];
        arr[0] = new Bus();
        arr[1] = new Taxi("Taxi!!");
        for (Car c : arr) {
            c.run();
        }
```

[결과]

```java
name: Bus!!
name: Taxi!!
버스 run
택시 run
```


이렇게 버스와 택시를 모두 Car 추상클래스로 일반화 시켜서 사용할 수 있다. Car[] 배열은 자동차의 배열이라고 생각하기보다 자동차 후손들의 배열이라고 생각하면 좋다. 일반화 시켜서 여러 객체를 하나인 것처럼 다룰 수 있다. (추상클래스 + 배열)


## 추상클래스 - 템플릿 메소드 패턴

추상 클래스를 가장 많이 사용하는 경우는 템플릿 메소드 패턴이다.

> 템플릿 메소드 패턴이란 특정 작업을 처리하는 일부분을 서브 클래스로 캡슐화하여 전체적인 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내용을 바꾸는 패턴으로 전체적으로는 동일하면서 부분적으로는 다른 구문으로 구성된 메서드의 코드 중복을 최소화 할 때
> 사용한다.


#### 템플릿 메소드 패턴의 예

여러 종류의 Controller를 만든다고 가정하자. 모든 Controller는 초기화-실행-마무리 단계로 구현되는데 초기화와 마무리 과정의 코드는 모두 동일하고 실행 단계의 코드만 Controller에 따라 달라진다. execute() 함수를 통해 자신이 가진 메소드들을 순서대로 호출하게 해서 초기화-실행-마무리 단계를 진행하도록 했다.

```java
public abstract class Controller {
    public void init() {
        System.out.println("초기화");
    }

    public void close() {
        System.out.println("마무리");
    }

    // Controller마다 매번 달라지는 코드
    public abstract void run();

   
    public void execute() {
        // 초기화
        this.init();
        // 실행
        this.run();
        // 마무리
        this.close();
    }
}


public class FirstController extends Controller {
    @Override
    public void run() {
        System.out.println("실행 코드: 1");
    }
}

public class ControllerMain {
    public static void main(String[] args) {
        Controller c1 = new FirstController();
        c1.execute();
    }
}
```

[결과]

```java
초기화
실행 코드: 1
마무리
```

이렇게 Controller를 상속받게 해서 매번 변화하는 코드만 구현하도록 강제했다. 그런데 템플릿 메소드는 이게 다가 아니다. 사용자가 실수로 전체 과정을 실행하는 execute() 메소드가 아닌 초기화 실행 메소드 init()만 호출했다면 문제가 된다.

init(), run(), close() 메소드는 사용자가 직접 호출하는 게 아닌 사용자가 호출한 execute()에 의해 호출되어야 한다. 서로 다른 패키지에 있다고 가정하고 init(), run(), close() 메소드의 접근제한자를 protected로 설정한다.

> 접근제한자 protected
>
> 같은 패키지이거나 상속받았을 경우 접근 가능하다.

이렇게 해주면 다른 패키지에 있는 ContollerMain에서는 init(), run(), close() 호출이 불가능하고, 상속받은 FirstController에서는 패키지가 달라도 상속받았으므로 호출이 가능해져서 run() 메소드 오버라이딩이 가능해진다.


하지만 FirstController에서 실수로 init() close() 메소드를 접근해서 수정하게 될 수도 있으므로 부모클래스 Controller에서 init()과 close() 메소드를 final로 구현해야한다. final이 붙은 메소드는 오버라이딩이 금지돼서 다른 클래스에서 바꿀 수 없게 되므로 문제를 방지할 수 있다.

```java
public abstract class Controller {
    protected final void init() {
        System.out.println("초기화");
    }

    protected final void close() {
        System.out.println("마무리");
    }

    protected abstract void run();

    public void execute() {
        // 초기화
        this.init();
        // 실행
        this.run();
        // 마무리
        this.close();
    }
}

```
