## Java IO

> IO란? Input과 Output으로 입출력을 뜻한다.

#### Java IO도 객체이다.

* Java IO에서 사용되는 객체는 자바 세상에서 사용되는 객체이다.
* Java IO가 제공하는 객체는 어떤 대상으로부터 읽어들여, 어떤 대상에게 쓰는 일을 한다.

#### Java IO는 조립되어 사용되도록 만들어졌다.

Decorator 패턴으로 만들어졌다. Decorator은 장식한다는 뜻인데 Java IO에서 장식과 장식 대상은 뭘까?

장식을 한 대상에 또 장식을 하고 또 장식을 하는 패턴을 Decorator 패턴이라고 한다. Component를 상속받은 Decorator는 Component를 가질 수 있다. 즉, Component를 상속받고 있는 것들을 가질 수 있다는 것이다.

![Decorate with decorator design pattern](https://www.javacodegeeks.com/wp-content/uploads/2012/12/decorator-design-pattern1.jpg)

#### 주인공과 장식을 구분할 수 있어야 한다.

Java IO에서 Component 역할을 수행하는 것은 추상클래스 4가지 InputStream, OutputStream, Reader, Writer이다. new로 인스턴스를 생성할 수 없다.

주인공 역할은 Component를 상속받고 있는 ConcreteComponent이다. Decorator도 Component를 상속받고 있지만 다른점은 생성자에 Component가 들어간다는 것이다. 즉, 장식은 InputStream, OutputStream, Reader, Writer를 생성자에서 받아들이는 것이다.

#### Java IO의 특수한 객체

* System.in: 표준 입력 (InputStream)
  * 키보드로 입력받을 때
* System.out: 표준 출력 (PrintStream)
  * 화면에 출력할 때
* System.err: 표준 에러 출력 (PrintStream)

#### Java IO의 클래스 상속도

![사용자 삽입 이미지](https://t1.daumcdn.net/cfile/tistory/22513341586A618005)

#### Java IO 클래스 이름이 중요하다.

![](https://mblogthumb-phinf.pstatic.net/MjAxNjEyMjBfMjY2/MDAxNDgyMjM3NzY0Nzk4.9r6Ilyq1iZBFfBuLldY6HtQ2sO3JDYAex4W2pjtDmksg.wIYaGpn6mGpeYuXauV5a7nDWtGiaLsSHZKTxB3OStzMg.JPEG.jimcarrey23/01.jpg?type=w2)


* ByteArray로 시작할 경우: 입력 클래스의 경우 byte 배열로부터 읽어들이고, 출력 클래스의 경우 클래스 내부의 자료구조에 출력을 한 후 출력된 결과를 byte 배열로 반환
* CharArray로 시작할 경우: char 배열
* Filter로 시작할 경우: 보통 직접 사용하는 것보다 상속받아 사용하는데 사용자가 원하는 내용만 필터링할 목적으로 사용
* Data로 시작할 경우: 다양한 데이터 형을 입출력. 특히 기본형 값(int, float, double 등) 출력하는데 유리
* Buffered로 시작할 경우: 프로그램에서 Buffer는 메모리를 의미하는데 입출력 시에 병목현상을 줄이고 싶을 경우 사용한다.
* RandomAccessFile: 입력이나 출력을 모두 할 수 있는 클래스로, 파일에서 임의의 위치의 내용을 읽거나 쓸 수 있는 기능 제공


#### Java IO 클래스는 생성자가 중요하다.

https://docs.oracle.com/javase/7/docs/api/index.html?java/io/package-summary.html

Java IO 클래스들 중 InputStream, OutputStream, Reader, Writer을 상속받는 클래스들이 있는데 그 중 생성자로 InputStream, OutputStream, Reader, Writer을 받고 있는 클래스들이 있다. 이 클래스들이 장식 역할을 하는 Decorator이고, 그 외의 클래스들이 주인공 역할을 하는 ConcreteComponent이다.

주인공은 어떤 대상으로부터 읽어들이고 쓸 것인가를 결정한다.


문제) 키보드로부터 한줄씩 입력 받아 화면에 한줄씩 출력하기

키보드를 사용하려면 System.in을 사용해야 하고, 화면에 출력하려면 System.out을 사용해야 한다. 키보드에서 입력받는다는 것은 문자를 입력받는 것이기 때문에 char 단위 입출력이 필요하다. char 단위 입출력 클래스는 Reader, Writer을 사용해야 한다.



**BufferedReader 클래스**

![image.png](assets/image-bfreader.png)

![image.png](assets/image-javaIO.png)

* readline메소드: 한줄 읽기. 더 이상 읽어들일 것이 없으면(EOF) null 반환
* BufferedReader는 주인공이 아닌 장식 역할이기에 생성자로 Reader를 받아줘야 한다. 그런데! Reader는 추상클래스이므로 Reader의 자식 클래스 중 하나를 받으면 된다.

![image.png](assets/image-reader.png)

* 자식들 중 어떤 클래스를 생성자로 받아야 할까?
  * BufferedReader를 만드는데 생성자로 또 받을 수 없으므로 탈락
  * CharArrayReader는 문자로부터 읽어들이는데 우리는 키보드로부터 읽어들이므로 탈락
  * FilterReader는 마찬가지로 생성자로 Reader를 받아야 하는 장식이므로 탈락
  * InputStreamReader는 InputStream을 받아들여야 하는 장식. 그런데 우리가 키보드로 받아들이려면 System.in을 사용해야 한다고 했었다. System.in은 InputStream을 상속받는 주인공이므로 BufferReader의 생성자로 알맞다.

한줄 쓰기: PrintStream, PrintWriter

```java
public class KeyboardIO {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        String line = null;

        while ((line = br.readLine()) != null) {
            System.out.println("읽어들인 값: " + line);
        }
    }
}
```



## File 클래스

java.io.File 클래스는 파일의 크기, 파일의 접근 권한, 파일의 삭제, 이름 변경 등의 작업을 할 수 있게 해준다.

> 디렉토리(폴더)도 팔일로 취급한다.

![image.png](assets/image-file.png)

new File 했다고 진짜 파일이 생성되는 것은 아니고 메모리 상에 인스턴스가 생성되는 것이다.


**파일 정보 알려주는 예제**

```java
import java.io.File;
import java.io.IOException;

public class FileInfo {
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("사용법: java FileInfo 파일이름");
            System.exit(0);
        }

        File f = new File(args[0]);
        if (f.exists()) { // 파일이 존재할 경우
            System.out.println("length: " + f.length());
            System.out.println("canRead: " + f.canRead());
            System.out.println("canWrite: " + f.canWrite());
            System.out.println("getAbsolutePath: " + f.getAbsolutePath());

            try {
                System.out.println("getCanonicalPath: " + f.getCanonicalPath());
            } catch (IOException e) {
                System.out.println(e);
            }

            System.out.println("getName: " + f.getName());
            System.out.println("getParent: " + f.getParent());
            System.out.println("getPath: " + f.getPath());

        } else { // 파일이 존재하지 않을 경우
            System.out.println("파일이 존재하지 않습니다.");
        } 
    }
}

```


**파일 삭제 예제**
